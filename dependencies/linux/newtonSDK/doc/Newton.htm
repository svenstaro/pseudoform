
<!-- Page generated by TwinText - PTLogica -->

<html>
<head>
<title>
Newton Game Dynamics 1.5
</title>

<style type="text/css">

<!--
/*  TwinText Style (c) PTLogica 2002 - 2003  */

 
/* Body */
body{font-family:"Verdana", sans-serif;font-size: 8pt; }

/* Body (Chapter) */
body.Main{background: #FFFFFF;color: #000000;  margin: 0; }

/*IE 5.5 */
li, table {  font-family: "Verdana", sans-serif; font-size: 8pt;  }

/* Project Title */
div.ProjectTitle {
	font-style: italic;
	font-size: 8pt;
	font-weight: normal;
	color: White;
	text-align: left;
}

/* Chapter's Title */
h1{font-family:"Verdana", sans-serif;font-size: 10pt;
font-weight: bold;text-align: left;margin-left: 0pt;margin-right: 0pt;margin-top: 0px;margin-bottom: 15px; padding-top: 5px;  padding-bottom: 5px;  padding-left: 10px;  background-color: #FFA500;  color: White;
                                                                                                                                                                                                                                                                                                            border-bottom: 1px solid #999999;
                                                                                                                                                                                                                                                                                          }

/* Common to all section text, including first section */
div.SectionText{margin-left: 10px;margin-right: 10px;margin-top: 10px;margin-bottom: 10px;         }

/* Contents or Summary */
h2{font-family:"Verdana", sans-serif;font-size: 9pt;font-weight: bold;text-align: left;margin-left: 5px;margin-right: 0pt;margin-top: 5pt;margin-bottom: 2pt;    padding-top: 5px;    padding-bottom: 5px;             }

/* Table of Contents */
div.Toc{margin-top: 30px;margin-bottom: 30px;    padding: 5px;  margin-left: 30px;  margin-right: 30px;    }
div.TocLinks{font-weight: normal;text-align: left;margin-left: 0pt;margin-right: 0pt;margin-top: 0pt;margin-bottom: 0pt;}
ul.TocLinks{}
li.TocLink{}
a.TocLink:link{text-decoration: underline;color: blue;background: transparent;  font-weight: normal; }
a.TocLink:visited{text-decoration: underline;color: blue;background: transparent; font-weight: normal;}
a.TocLink:hover{text-decoration: underline;color: #0066FF;background: transparent; font-weight: normal;}


/* Summary */
div.Summary{margin-top: 20px;margin-bottom: 40px;    padding: 5px;  margin-left: 20px;  margin-right: 20px; }
table.SummaryTable{ margin-top: 10px;  margin-bottom: 15px;  background-color: White;      }
tr.SummaryRow {  }
td.SummaryLink{font-weight: normal;text-align: left;width: 15%;        padding: 3px;  background: White;  vertical-align: top;             }
td.SummaryText{text-align: left;      padding: 3px;  background-color: transparent;  background: #F1F1F1;  vertical-align: top;           }
a.SummaryLink:link{text-decoration: underline;color: blue;background: transparent;  font-weight: normal; }
a.SummaryLink:visited{text-decoration: underline;color: blue;background: transparent; font-weight: normal;}
a.SummaryLink:hover{text-decoration: underline;color: #0066FF;background: transparent; font-weight: normal;}


/* Sections */
div.AllSections{margin-top: 0;margin-bottom: 70px;  margin-left: 0;  margin-right: 0;  padding: 0px;   }

div.Section{margin-top: 30px;margin-bottom: 10px;}
h3{font-family:"Verdana", sans-serif;font-size: 9pt;font-weight: bold;text-align: left;margin-left: 0pt;margin-right: 0pt;margin-top: 5pt;margin-bottom: 10px;border-bottom: 1px solid #FFA500;  padding-left: 10px;  padding-bottom: 2px;  background: transparent;  padding-top: 3px;       }

/* API Box */
div.Api{font-family:"Courier New", monospace;font-size: 8pt;margin-left: 15px;margin-right: 15px;margin-top: 15px;margin-bottom: 15px;padding: 2px;background: #F1F1F1;color: #000000;  border: 1px solid #999999;    }
font.ApiName{font-weight: bold;}

/* Section Text Elements */
h4{font-family:"Verdana", sans-serif;font-size: 8pt;font-weight: bold;margin-left: 0pt;margin-right: 0pt;margin-top: 5pt;margin-bottom: 2pt;  font-style: normal;       }
pre{font-family:"Courier New", monospace;font-size: 8pt;white-space: pre;margin-top: 7pt;margin-bottom: 7pt;color: #000000;    padding: 5px;  margin-left: 5px;  margin-right: 5px;  background: #F1F1F1;        }
font.HighText{background: #FFFFE1;   }
ul{}
li{list-style: disc;}
a:link{text-decoration: underline;color: #0000FF;background: transparent;}
a:visited{text-decoration: underline;color: #0000FF;background: transparent;}
a:hover{text-decoration:underline;color: #0066FF;background: transparent;}
	
/* Definitions Table */
table.DefTable{ margin-left: 20px;  margin-right: 20px;   }
tr.Def{  }
td.Def{font-family:"Courier New", monospace;font-size: 8pt;  font-weight: normal;  padding-left: 5px;  padding-right: 5px;  white-space: nowrap;  text-align: left;  vertical-align: top;  background: transparent;  margin: 2px;              }
td.DefSep{font-family:"Courier New", monospace;font-size: 8pt;padding-right: 5pt;padding-left: 5pt;  text-align: center;  vertical-align: top;  background: transparent;   }
td.DefText{ text-align: left;  vertical-align: top;  background: transparent;  margin: 2px;       }

/* Copyright */
div.Copy { padding: 15px;  }

/* Footer */
div.Footer{   margin-top: 10px;  padding: 5px;    background: #FFA500;  border-top: 1px solid #999999;   color: White;         }

div.SourceLocation{background: transparent;  font-size: 8pt;  margin-bottom: 10px;  margin-left: 10px;  font-family: Verdana, sans-serif;    }
div.LastGenerated{background: transparent;  font-size: 8pt;  margin-left: 10px;  font-family: Verdana, sans-serif;   }


/* Navigation */
body.Side{background: #F1F1F1;color: Black;  margin: 0px;  padding: 0px;  }
div.Side{}
div.SideTitle{ font-weight: bold;  padding: 3px 10px;  font-size: 10pt;  font-family: Verdana, sans-serif;  margin-top: 2px;        }
div.SideText{ padding: 10px; padding-top: 18px;  }
div.SideDetail {  padding-top: 1px; }
ul.SideDetail{ }
li.SideDetail{ }
a.SideDetail:link { text-decoration: underline; color: Blue; font-family: Verdana, sans-serif; font-size: 8pt;  font-weight: normal;      }
a.SideDetail:visited {  text-decoration: underline; color: Blue; font-family: Verdana, sans-serif; font-size: 8pt;  font-weight: normal;  }
a.SideDetail:hover {  text-decoration: underline; color: #0066FF; font-family: Verdana, sans-serif; font-size: 8pt;  font-weight: normal;  }

table.LinksTable{ padding-left: 10px; }
tr.SideLink{}
td.SideLink{}
a.SideLink:link { text-decoration: underline; color:Blue; font-family: Verdana, sans-serif; font-size: 8pt;  }
a.SideLink:visited {  text-decoration: underline; color: Blue; font-family: Verdana, sans-serif; font-size: 8pt; }
a.SideLink:hover {  text-decoration: underline; color: #0066FF; font-family: Verdana, sans-serif; font-size: 8pt;  }










-->

</style>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="TwinText">

</head>
<body class=Main>
<h1>
Newton Game Dynamics 1.5
</h1>
<div class=SectionText>
   Advanced physics engine for real-time simulation of rigid bodies.
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
Created by Julio Jerez 2003
</td>
<td class=DefSep>-</td>
<td class=DefText>
2005. All rights reserved.
</td>
</tr>
</table>

<p>
                                                                                                    
</div>
<div class=AllSections>
<div class=Section>
<h3>
<a NAME="World^interface"></a>
<a NAME="World interface"></a>
World interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreate"></a>
<a NAME="NewtonCreate"></a>
NewtonCreate
</h3>
<div class=Api>
NewtonWorld* <font class=ApiName>NewtonCreate</font>(<br> NewtonAllocMemory mallocFnt,<br> NewtonFreeMemory mfreeFnt)
</div>
<div class=SectionText>
Create an instance of the Newton world.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>NewtonAllocMemory</b> mallocFnt
</td>
<td class=DefSep>-</td>
<td class=DefText>
	is a pointer to the memory allocator callback function. If this parameter is 
  									NULL the standard <b>malloc</b> function is used.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonFreeMemory</b> mfreeFnt
</td>
<td class=DefSep>-</td>
<td class=DefText>
	is a pointer to the memory release callback function. If this parameter is NULL
  									the standard <b>free</b> function is used.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> a pointer to an instance of the Newton world.
  
<p>   <h4>Remarks</h4> this function must be called before any of the other API functions.
  
<p>  
   <h4>See also</h4> <a HREF="#NewtonDestroy">NewtonDestroy</a>, <a HREF="#NewtonDestroyAllBodies">NewtonDestroyAllBodies</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonDestroy"></a>
<a NAME="NewtonDestroy"></a>
NewtonDestroy
</h3>
<div class=Api>
void <font class=ApiName>NewtonDestroy</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Destroy an instance of the Newton world.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function will destroy the entire Newton world.
  
<p>   <h4>See also</h4> <a HREF="#NewtonCreate">NewtonCreate</a>, <a HREF="#NewtonDestroyAllBodies">NewtonDestroyAllBodies</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonGetGlobalScale"></a>
<a NAME="NewtonGetGlobalScale"></a>
NewtonGetGlobalScale
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonGetGlobalScale</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Get the global scale factor.
   
<p>   <h4>Remarks</h4> the physics system in theory should be dimensionless, however in practice the engine have to be implemented with
   limited precision floating numbers and is also built for real-time simulation, it is inevitable that tolerances have to be used in order to increase performance, and 
   reduce instabilities. These tolerances make the engine dimension dependent, for example let say a rigid body is considered at rest when 
   its velocity is less than 0.01 units per second for some frames. For a program using meters as unit this translate to 0.01 meters per second, 
   however for a program using centimeter this translate to 0.0001 meter per second, since the precession of speed is independent of the unit system, 
   this means that in the second system the engine has to work much harder to bring the body to rest. A solution for this is to scale all tolerances 
   to match the unit system. The argument <b>globalScale</b> must be a constant to convert the unit system in the game to meters, for example if in your game you are using 39 units is a meter, 
   the <b>globaScale</b> must be 39. The exact conversion factor does not have to be exact, but the closer it is to reality the better performance the application will get.
   Applications that are already using meters as the unit system must pass 1.0 as <b>globalScale</b>.
  
<p>  <h4>See also</h4> <a HREF="#NewtonCreate">NewtonCreate</a>
  dFloat NewtonGetGlobalScale(const NewtonWorld* newtonWorld)
  {
  	Newton *world;
  	world = (Newton *) newtonWorld;
  	return world->GetGlobalScale();
  	return dgFloat32(1.0f);
  }


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSetPlatformArchitecture"></a>
<a NAME="NewtonSetPlatformArchitecture"></a>
NewtonSetPlatformArchitecture
</h3>
<div class=Api>
void <font class=ApiName>NewtonSetPlatformArchitecture</font>(<br> const NewtonWorld* newtonWorld,<br> int mode)
</div>
<div class=SectionText>
Set the current platform hardware architecture.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> model
</td>
<td class=DefSep>-</td>
<td class=DefText>
model of operation 0 = default, 1 = medium, n = best.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing
  
<p>   <h4>Remarks</h4> This function allows the application to configure the Newton to take advantage  
   for specific hardware architecture in the same platform.
  
<p>   <h4>0</h4> force the hardware lower common denominator for the running platform.
  
<p>   <h4>1</h4> will try to use common floating point enhancement like spacial instruction set 
   on the specific architecture. This mode made lead to result that differ from mode 1 and 2 as the accumulation 
   round off errors maybe different. 
  
<p>   <h4>2</h4> the engine will try to use the best possible hardware setting found in the current platform 
   this is the default configuration. This mode made lead to result that differ from mode 1 and 2 as the accumulation 
   round off errors maybe different. 
  
<p>   <h4>Remarks</h4> the only hardware mode guarantee to work is mode 0. all other are only 
   hints to the engine, for example setting mode 1 will take not effect on CPUs without  
   specially floating point instructions set. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSetSolverModel"></a>
<a NAME="NewtonSetSolverModel"></a>
NewtonSetSolverModel
</h3>
<div class=Api>
void <font class=ApiName>NewtonSetSolverModel</font>(<br> const NewtonWorld* newtonWorld,<br> int model)
</div>
<div class=SectionText>
Set the solver precision mode.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> model
</td>
<td class=DefSep>-</td>
<td class=DefText>
model of operation 0 = exact, 1 = adaptive, n = linear. The default is exact.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing
  
<p>   <h4>Remarks</h4> This function allows the application to configure the Newton solver to work in three different modes.  
  
<p>   <h4>0</h4> Is the exact mode. This is good for application where precision is more important than speed, ex: realistic simulation.
  
<p>   <h4>1</h4> Is the adaptive mode, the solver is not as exact but the simulation will still maintain a high degree of accuracy. 
   This mode is good for applications were a good degree of stability is important but not as important as speed. 
  
<p>   <h4>n</h4> Linear mode. The solver will not try to reduce the joints relative acceleration errors to below some limit, 
   instead it will perform up to n passes over the joint configuration each time reducing the acceleration error, 
   but it will terminate when the number of passes is exhausted regardless of the error magnitude. 
   In general this is the fastest mode and is is good for applications where speed is the only important factor, ex: video games.
  
<p>   <h4>Remarks</h4> the adaptive friction model combined with the linear model make for the fastest possible configuration 
   of the Newton solver. This setup is best for games.
   If you need the best realistic behavior, we recommend the use of the exact solver and exact friction model which are the defaults.
  
<p>   <h4>See also</h4> <a HREF="#NewtonSetFrictionModel">NewtonSetFrictionModel</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSetFrictionModel"></a>
<a NAME="NewtonSetFrictionModel"></a>
NewtonSetFrictionModel
</h3>
<div class=Api>
void <font class=ApiName>NewtonSetFrictionModel</font>(<br> const NewtonWorld* newtonWorld,<br> int model)
</div>
<div class=SectionText>
Set coulomb model of friction.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> model
</td>
<td class=DefSep>-</td>
<td class=DefText>
friction model;  0 = exact coulomb, 1 = adaptive coulomb, The default is exact.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function allows the application to chose between and exact or an adaptive coulomb friction model 
   
<p>   <h4>0</h4> Is the exact model. Friction forces are calculated in each frame. 
   This model is good for applications where precision is more important than speed, ex: realistic simulation.
  
<p>   <h4>1</h4> Is the adaptive model. Here values from previous frames are used to determine the maximum friction values of the current frame. 
   This is about 10% faster than the exact model however it may introduce strange friction behaviors. For example a 
   bouncing object tumbling down a ramp will act as a friction less object because the contacts do not have continuity. 
   In general each time a new contact is generated the friction value is zero, only if the contact persist a non zero 
   friction values is used. The second effect is that if a normal force is very strong, and if the contact is suddenly 
   destroyed, a very strong friction force will be generated at the contact point making the object react in a non-familiar way. 
  
<p>   <h4>Remarks</h4> the adaptive friction model combined with the linear model make for the fastest possible configuration 
   of the Newton solver. This setup is best for games.
   If you need the best realistic behavior, we recommend the use of the exact solver and exact friction model which are the defaults.
  
<p>   <h4>See also</h4> <a HREF="#NewtonSetSolverModel">NewtonSetSolverModel</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUpdate"></a>
<a NAME="NewtonUpdate"></a>
NewtonUpdate
</h3>
<div class=Api>
void <font class=ApiName>NewtonUpdate</font>(<br> const NewtonWorld* newtonWorld,<br> dFloat timestep)
</div>
<div class=SectionText>
Advance the simulation by an amount of time.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> timestep
</td>
<td class=DefSep>-</td>
<td class=DefText>
time step in seconds
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing
  
<p>   <h4>Remarks</h4> This function will advance the simulation by the amount of time specified by <b>timestep</b>. The Newton Engine does 
   not perform sub-steps, and does not need tuning parameters. It is the responsibility of the application to 
   ensure that <b>timestep</b> is small enough to guarantee physics stability. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSetMinimumFrameRate"></a>
<a NAME="NewtonSetMinimumFrameRate"></a>
NewtonSetMinimumFrameRate
</h3>
<div class=Api>
void <font class=ApiName>NewtonSetMinimumFrameRate</font>(<br> const NewtonWorld* newtonWorld,<br> dFloat frameRate)
</div>
<div class=SectionText>
Set the minimum frame rate at which the simulation can run.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> frameRate
</td>
<td class=DefSep>-</td>
<td class=DefText>
minimum frame rate of the simulation in frame per second. This value is clamped between 60fps and 1000fps
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> nothing
  
<p>   <h4>Remarks</h4> the default minimum frame rate of the simulation is 60 frame per second. When the simulation falls below the specified minimum frame, Newton will
   perform sub steps in order to meet the desired minimum FPS. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonGetTimeStep"></a>
<a NAME="NewtonGetTimeStep"></a>
NewtonGetTimeStep
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonGetTimeStep</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Return the correct time step for this simulation update.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> This application can used this function to get the currect siulation time step. 
   
<p>   <h4>Return</h4> correct update timestep.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonDestroyAllBodies"></a>
<a NAME="NewtonDestroyAllBodies"></a>
NewtonDestroyAllBodies
</h3>
<div class=Api>
void <font class=ApiName>NewtonDestroyAllBodies</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Remove all bodies and joints from the newton world.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is a pointer to the Newton world
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing
  
<p>   <h4>Remarks</h4> This function will destroy all bodies and all joints in the Newton world, but it will retain group IDs. 
   Use this function for when you want to clear the world but preserve all the group IDs and material pairs.
  
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialDestroyAllGroupID">NewtonMaterialDestroyAllGroupID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSetWorldSize"></a>
<a NAME="NewtonSetWorldSize"></a>
NewtonSetWorldSize
</h3>
<div class=Api>
void <font class=ApiName>NewtonSetWorldSize</font>(<br> const NewtonWorld* newtonWorld,<br> const dFloat* minPtr,<br> const dFloat* maxPtr)
</div>
<div class=SectionText>
Set the size of the Newton world.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *minPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the minimum point of the world bounding box
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *maxPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the maximum point of the world bounding box
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The Newton world must have a finite size. The size of the world is set to a box +- 100 units in all three dimensions
   at creation time and after a call to the function <u>NewtonRemoveAllBodies</u>
  
<p>   <h4>See also</h4> <a HREF="#NewtonSetBodyLeaveWorldEvent">NewtonSetBodyLeaveWorldEvent</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSetBodyLeaveWorldEvent"></a>
<a NAME="NewtonSetBodyLeaveWorldEvent"></a>
NewtonSetBodyLeaveWorldEvent
</h3>
<div class=Api>
void <font class=ApiName>NewtonSetBodyLeaveWorldEvent</font>(<br> const NewtonWorld* newtonWorld,<br> NewtonBodyLeaveWorld callback)
</div>
<div class=SectionText>
Set the event callback function to be called in the event a body is escaping the limits of the world
   during simulation time.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonBodyLeaveWorld</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the function callback
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing
  
<p>   <h4>Remarks</h4> When a body moves outside the bounding box that defines the world space the body is automatically disabled
   and Newton calls the application defined callback function <b>NewtonBodyLeaveWorld callback</b>. 
   The application should decide how to handle the event, because Newton will make the callback once.
   The only options available to the application are: do nothing or destroy the object. 
  
<p>   <h4>Remarks</h4> if the application wants to reinitialize the body, it will have to used the function 
   <a HREF="#NewtonBodySetMatrixRecursive">NewtonBodySetMatrixRecursive</a>, this is because it is possible that the rigid body is part of a set of 
   articulate bodies and only one part leave the world while the others are still inside the world volume,
   and in and situation like this the function NewtonSetMatrix will lead to unpredictable results.
  
<p>   <h4>See also</h4> <a HREF="#NewtonSetWorldSize">NewtonSetWorldSize</a>, <a HREF="#NewtonBodySetMatrixRecursive">NewtonBodySetMatrixRecursive</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonWorldFreezeBody"></a>
<a NAME="NewtonWorldFreezeBody"></a>
NewtonWorldFreezeBody
</h3>
<div class=Api>
void <font class=ApiName>NewtonWorldFreezeBody</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonBody* body)
</div>
<div class=SectionText>
Remove the body from the active simulation list.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *body
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body to be frozen
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> When a body is created it is automatically placed in the active simulation list. As an optimization 
   for large scenes, you may use this function to put background bodies in an inactive equilibrium state.
  
<p>   <h4>Remarks</h4> This function tells Newton that this body does not currently need to be simulated.
   However, if the body is part of a larger configuration it may be affected indirectly by the reaction forces
   of objects that it is connected to.
  
<p>   <h4>See also</h4> <a HREF="#NewtonWorldUnfreezeBody">NewtonWorldUnfreezeBody</a>, <a HREF="#NewtonBodySetAutoFreeze">NewtonBodySetAutoFreeze</a>, <a HREF="#NewtonBodyGetAutoFreeze">NewtonBodyGetAutoFreeze</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonWorldUnfreezeBody"></a>
<a NAME="NewtonWorldUnfreezeBody"></a>
NewtonWorldUnfreezeBody
</h3>
<div class=Api>
void <font class=ApiName>NewtonWorldUnfreezeBody</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonBody* body)
</div>
<div class=SectionText>
Add the body to the active simulation list.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *body
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body to be activated
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing
  
<p>   <h4>Remarks</h4> This function tells Newton to simulate the rigid body <b>body</b>.
  
<p>   <h4>See also</h4> <a HREF="#NewtonWorldFreezeBody">NewtonWorldFreezeBody</a>, <a HREF="#NewtonBodySetAutoFreeze">NewtonBodySetAutoFreeze</a>, <a HREF="#NewtonBodyGetAutoFreeze">NewtonBodyGetAutoFreeze</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonWorldForEachBodyDo"></a>
<a NAME="NewtonWorldForEachBodyDo"></a>
NewtonWorldForEachBodyDo
</h3>
<div class=Api>
void <font class=ApiName>NewtonWorldForEachBodyDo</font>(<br> const NewtonWorld* newtonWorld,<br> NewtonBodyIterator callback)
</div>
<div class=SectionText>
Iterate thought every body in the world calling the function callback.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonBodyIterator</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
application define callback
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
   
<p>   <h4>Remarks</h4> The application can call this function to iterate thought every body in the world. 
   the application should provide the function <b>NewtonBodyIterator callback</b> to be called by Newton for every body in the world 
  
<p>   <h4>Remarks</h4> this function affect severally the performance of Newton. The application should call this function only for debugging purpose
   See also: <a HREF="#NewtonBodyForEachPolygonDo">NewtonBodyForEachPolygonDo</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonGetVersion"></a>
<a NAME="NewtonGetVersion"></a>
NewtonGetVersion
</h3>
<div class=SectionText>
Return the current library version number.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the newton world.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> release decimal three digit value x.xx
   the first digit:  is mayor version number (interface changes among other things)   
   the second digit: is mayor patch number (new features, and bug fixes) 
   third digit: is minor bug fixed patch.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonWorldSetUserData"></a>
<a NAME="NewtonWorldSetUserData"></a>
NewtonWorldSetUserData
</h3>
<div class=Api>
void <font class=ApiName>NewtonWorldSetUserData</font>(<br> const NewtonWorld* newtonWorld,<br> void* userData)
</div>
<div class=SectionText>
Store a user defined data value with the world.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userDataPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the user defined user data value.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The application can store a user defined value with the Newton world. The user data is useful for application developing 
   object oriented classes based on the Newton API.
   
<p>   <h4>See also</h4> <a HREF="#NewtonWorldGetUserData">NewtonWorldGetUserData</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonWorldGetUserData"></a>
<a NAME="NewtonWorldGetUserData"></a>
NewtonWorldGetUserData
</h3>
<div class=Api>
void* <font class=ApiName>NewtonWorldGetUserData</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Retrieve a user previously stored user define value with the world.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> user data value.
  
<p>   <h4>Remarks</h4> The application can store a user defined value with the Newton world. The user data is useful for application developing 
   object oriented classes based on the Newton API.
   
<p>   <h4>See also</h4> NewtonWorldGetUserData  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonWorldRayCast"></a>
<a NAME="NewtonWorldRayCast"></a>
NewtonWorldRayCast
</h3>
<div class=Api>
void <font class=ApiName>NewtonWorldRayCast</font>(<br> const NewtonWorld* newtonWorld,<br> const dFloat* p0,<br> const dFloat* p1,<br> NewtonWorldRayFilterCallback filter,<br> void* userData)
</div>
<div class=SectionText>
Shoot a ray from p0 to p1 and call the application callback with each ray intersection.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *p0
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats containing the beginning of the ray in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *p1
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats containing the end of the ray in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonWorldRayFilterCallback</b> filter
</td>
<td class=DefSep>-</td>
<td class=DefText>
user define function to be called for each body hit during the ray scan.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userData
</td>
<td class=DefSep>-</td>
<td class=DefText>
user data to be passed to the filter callback.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
   
<p>   <h4>Remarks</h4> The ray cast function will call the application with each body intersecting the line segment. 
   By writing the callback filter function in different ways the application can implement different flavors of ray casting. 
   For example an all body ray cast can be easily implemented by having the filter function always returning 1.0, and copying each 
   rigid body into an array of pointers; a closest hit ray cast can be implemented by saving the body with the smaller intersection 
   parameter and returning the parameter t; and a report the first body hit can be implemented by having the filter function returning 
   zero after the first call and saving the pointer to the rigid body.
  
<p>   <h4>Remarks</h4> The most common use for the ray cast function is the closest body hit, In this case it is important, for performance reasons, 
   that the filter function returns the intersection parameter. If the filter function returns a value of zero the ray cast will terminate 
   immediately.
  
<p>   <h4>Remarks</h4> The ray cast function is provided as an utility function, this means that even thought the function is very high performance 
   by function standards, it can not by batched and therefore it can not be an incremental function. For example the cost of calling 1000 
   ray cast is 1000 times the cost of calling one ray cast. This is much different than the collision system where the cost of calculating 
   collision for 1000 pairs in much, much less that the 1000 times the cost of one pair. Therefore this function must be used with care, 
   as excessive use of it can degrade performance.


</div>
</div>
<div class=Section>
<h3>
<a NAME="GroupID^interface"></a>
<a NAME="GroupID interface"></a>
GroupID interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetDefaultGroupID"></a>
<a NAME="NewtonMaterialGetDefaultGroupID"></a>
NewtonMaterialGetDefaultGroupID
</h3>
<div class=Api>
int <font class=ApiName>NewtonMaterialGetDefaultGroupID</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Get the value of the default MaterialGroupID.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> The ID number for the default Group ID.
  
<p>   <h4>Remarks</h4> Group IDs can be interpreted as the nodes of a dense graph. The edges of the graph are the physics materials.
   When the Newton world is created, the default Group ID is created by the engine.	
   When bodies are created the application assigns a group ID to the body. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialCreateGroupID"></a>
<a NAME="NewtonMaterialCreateGroupID"></a>
NewtonMaterialCreateGroupID
</h3>
<div class=Api>
int <font class=ApiName>NewtonMaterialCreateGroupID</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Create a new MaterialGroupID.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> The ID of a new GroupID.
  
<p>   <h4>Remarks</h4> Group IDs can be interpreted as the nodes of a dense graph. The edges of the graph are the physics materials.
   When the Newton world is created, the default Group ID is created by the engine.	
   When bodies are created the application assigns a group ID to the body. 
  
<p>   <h4>Note</h4> The only way to destroy a Group ID after its creation is by destroying all the bodies and calling the function  *NewtonMaterialDestroyAllGroupID*.
  
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialDestroyAllGroupID">NewtonMaterialDestroyAllGroupID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialDestroyAllGroupID"></a>
<a NAME="NewtonMaterialDestroyAllGroupID"></a>
NewtonMaterialDestroyAllGroupID
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialDestroyAllGroupID</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Remove all groups ID from the Newton world.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function removes all groups ID from the Newton world. 
   This function must be called after there are no more rigid bodies in the word.
  
<p>   <h4>See also</h4> <a HREF="#NewtonDestroyAllBodies">NewtonDestroyAllBodies</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Material^setup^interface"></a>
<a NAME="Material setup interface"></a>
Material setup interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetDefaultCollidable"></a>
<a NAME="NewtonMaterialSetDefaultCollidable"></a>
NewtonMaterialSetDefaultCollidable
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetDefaultCollidable</font>(<br> const NewtonWorld* newtonWorld,<br> int id0,<br> int id1,<br> int state)
</div>
<div class=SectionText>
Set the material defined by the interaction between two physics groups to be collidable or non-collidable by default.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id0
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id0
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id1
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id1
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> state
</td>
<td class=DefSep>-</td>
<td class=DefText>
state for this material: 1 = collidable; 0 = non collidable
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContinuousCollisionMode"></a>
<a NAME="NewtonMaterialSetContinuousCollisionMode"></a>
NewtonMaterialSetContinuousCollisionMode
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContinuousCollisionMode</font>(<br> const NewtonWorld* newtonWorld,<br> int id0,<br> int id1,<br> int state)
</div>
<div class=SectionText>
Set the material defined by the interaction between two physics groups to enable or desable continue collision.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id0
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id0
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id1
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id1
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> state
</td>
<td class=DefSep>-</td>
<td class=DefText>
state for this material: 1 = continue collision on; 0 = continue collision off, default mode is on
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> continue collision mode enable allow the engine to predict colliding contact on rigid bodies
   Moving at high speed of subject to strong forces.
  
<p>   <h4>Remarks</h4> continue collision mode does not prevent rigid bodies from interpenetration instead it prevent bodies from 
   passing trough each others by extrapolating contact points when the bodies normal contact calculation determine the bodies are not colliding. 
  
<p>   <h4>Remarks</h4> for performance reason the bodies angular velocities is only use on the broad face of the collision, 
   but not on the contact calculation. 
   
<p>   <h4>Remarks</h4> continue collision does not perform back tracking to determine time of contact, instead it extrapolate contact by incrementally 
   extruding the collision geometries of the two colliding bodies along the linear velocity of the bodies during the time step, 
   if during the extrusion colliding contact are found, a collision is declared and the normal contact resolution is called. 
  
<p>   <h4>Remarks</h4> for continue collision to be active the continue collision mode must on the material pair of the colliding bodies as well as on at least one of the two colliding bodies.
  
<p>   <h4>Remarks</h4> Because there is penalty of about 40% to 80% depending of the shape complexity of the collision geometry, this feature is set 
   off by default. It is the job of the application to determine what bodies need this feature on. Good guidelines are: very small objects, 
   and bodies that move a height speed.  
   
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetContinuousCollisionMode">NewtonBodySetContinuousCollisionMode</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetDefaultFriction"></a>
<a NAME="NewtonMaterialSetDefaultFriction"></a>
NewtonMaterialSetDefaultFriction
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetDefaultFriction</font>(<br> const NewtonWorld* newtonWorld,<br> int id0,<br> int id1,<br> dFloat staticFriction,<br> dFloat kineticFriction)
</div>
<div class=SectionText>
Set the default coefficients of friction for the material defined by the interaction between two physics groups.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id0
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id0
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id1
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id1
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> staticFriction
</td>
<td class=DefSep>-</td>
<td class=DefText>
	static friction coefients
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> kineticFriction
</td>
<td class=DefSep>-</td>
<td class=DefText>
dynamic coefficient of friction
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> <b>staticFriction</b> and <b>kineticFriction</b> must be positive values. <b>kineticFriction</b> must be lower than <b>staticFriction</b>.
   It is recommended that <b>staticFriction</b> and <b>kineticFriction</b> be set to a value lower or equal to 1.0, however because some synthetic materials
   can have higher than one coeficient of friction Newton allows for the coeficient of friction to be as high as 2.0.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetDefaultElasticity"></a>
<a NAME="NewtonMaterialSetDefaultElasticity"></a>
NewtonMaterialSetDefaultElasticity
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetDefaultElasticity</font>(<br> const NewtonWorld* newtonWorld,<br> int id0,<br> int id1,<br> dFloat elasticCoef)
</div>
<div class=SectionText>
Set the default coefficients of restitution (elasticity) for the material defined by the interaction between two physics groups.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id0
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id0
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id1
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id1
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> elasticCoef
</td>
<td class=DefSep>-</td>
<td class=DefText>
static friction coefficients
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> <b>elasticCoef</b> must be a positive value. 
   It is recommended that <b>elasticCoef</b> be set to a value lower or equal to 1.0


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetDefaultSoftness"></a>
<a NAME="NewtonMaterialSetDefaultSoftness"></a>
NewtonMaterialSetDefaultSoftness
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetDefaultSoftness</font>(<br> const NewtonWorld* newtonWorld,<br> int id0,<br> int id1,<br> dFloat softnessCoef)
</div>
<div class=SectionText>
Set the default softness coefficients for the material defined by the interaction between two physics groups.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id0
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id0
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id1
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id1
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> softnessCoef
</td>
<td class=DefSep>-</td>
<td class=DefText>
softness coefficient
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> <b>softnessCoef</b> must be a positive value. 
   It is recommended that <b>softnessCoef</b> be set to value lower or equal to 1.0
   A low value for <b>softnessCoef</b> will make the material soft. A typical value for <b>softnessCoef</b> is 0.15


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetCollisionCallback"></a>
<a NAME="NewtonMaterialSetCollisionCallback"></a>
NewtonMaterialSetCollisionCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetCollisionCallback</font>(<br> const NewtonWorld* newtonWorld,<br> 
	int id0,<br> 
	int id1,<br> 
	void *userData,<br>
	NewtonContactBegin beginCallback,<br> 
	NewtonContactProcess processCallback,<br> 
	NewtonContactEnd endCallback)
</div>
<div class=SectionText>
Set userData and the functions event handlers for the material defined by the interaction between two physics groups.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id0
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id0.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id1
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id1.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userData
</td>
<td class=DefSep>-</td>
<td class=DefText>
user data value.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonContactBegin</b> beginCallback
</td>
<td class=DefSep>-</td>
<td class=DefText>
address of the event function called before contact calculation for collision. This parameter can be NULL.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonContactProcess</b> processCallback
</td>
<td class=DefSep>-</td>
<td class=DefText>
address of the event function called for every contact resulting from contact calculation. This parameter can be NULL.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonContactEnd</b> endCallback
</td>
<td class=DefSep>-</td>
<td class=DefText>
address of the event function called after all contacts are processed. This parameter can be NULL.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> When the AABB extend of the collision geometry of two bodies overlap, Newton collision system retrieves the material 
   interaction that defines the behavior between the pair of bodies. The material interaction is collected from a database of materials, 
    indexed by the material gruopID assigned to the bodies. If the material is tagged as non collidable, 
   then no action is taken and the simulation continues. 
   If the material is tagged as collidable, and a <b>beginCallback</b> was set for this material, then the <b>beginCallback</b> function is called. 
   If the function  *beginCallback* returns 0, no further action is taken for this material (this can be use to ignore the interaction under 
   certain conditions). If the function  *beginCallback* returns 1, Newton proceeds to calculate the array of contacts for the pair of 
   colliding bodies. If the function <b>processCallback</b> was set, the application receives a callback for every contact found between the 
   two colliding bodies. Here the application can perform fine grain control over the behavior of the collision system. For example, 
   rejecting the contact, making the contact frictionless, applying special effects to the surface etc. 
   After all contacts are processed and if the function <b>endCallback</b> was set, Newton calls <b>endCallback</b>. 
   Here the application can collect information gathered during the contact-processing phase and provide some feedback to the player. 
   A typical use for the material callback is to play sound effects. The application passes the address of structure in the <b>userData</b> along with 
   three event function callbacks. When the function <b>beginCallback</b> is called by Newton, the application resets a variable say <b>maximumImpactSpeed</b>. 
   Then for every call to the function <b>processCallback</b>, the application compares the impact speed for this contact with the value of 
   <b>maximumImpactSpeed</b>, if the value is larger, then the application stores the new value along with the position, and any other quantity desired. 
   When the application receives the call to <b>endCallback</b> the application plays a 3d sound based in the position and strength of the contact.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetUserData"></a>
<a NAME="NewtonMaterialGetUserData"></a>
NewtonMaterialGetUserData
</h3>
<div class=SectionText>
Get userData associated with this material.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id0
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id0.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id1
</td>
<td class=DefSep>-</td>
<td class=DefText>
group id1.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="Contact^behavior^control^interface"></a>
<a NAME="Contact behavior control interface"></a>
Contact behavior control interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialDisableContact"></a>
<a NAME="NewtonMaterialDisableContact"></a>
NewtonMaterialDisableContact
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialDisableContact</font>(const NewtonMaterial* materialHandle)
</div>
<div class=SectionText>
Disable processing for the contact. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetMaterialPairUserData"></a>
<a NAME="NewtonMaterialGetMaterialPairUserData"></a>
NewtonMaterialGetMaterialPairUserData
</h3>
<div class=Api>
void* <font class=ApiName>NewtonMaterialGetMaterialPairUserData</font>(const NewtonMaterial* materialHandle)
</div>
<div class=SectionText>
Get the userData set by the application when it created this material pair.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Application user data.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetContactFaceAttribute"></a>
<a NAME="NewtonMaterialGetContactFaceAttribute"></a>
NewtonMaterialGetContactFaceAttribute
</h3>
<div class=Api>
unsigned <font class=ApiName>NewtonMaterialGetContactFaceAttribute</font>(const NewtonMaterial* materialHandle)
</div>
<div class=SectionText>
Return the face attribute assigned to this face when for a user defined collision or a Newton collision tree.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> face attribute for collision trees. Zero if the contact was generated by two convex collisions. 
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
  
<p>   <h4>Remarks</h4> this function can be used by the application to retrieve the face id of a polygon for a collision tree.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetCurrentTimestep"></a>
<a NAME="NewtonMaterialGetCurrentTimestep"></a>
NewtonMaterialGetCurrentTimestep
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonMaterialGetCurrentTimestep</font>(const NewtonMaterial* materialHandle)
</div>
<div class=SectionText>
Get the current time step.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> the current time step.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler. The function can be useful for the implementation of powered contacts.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetContactNormalSpeed"></a>
<a NAME="NewtonMaterialGetContactNormalSpeed"></a>
NewtonMaterialGetContactNormalSpeed
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonMaterialGetContactNormalSpeed</font>(<br> const NewtonMaterial* materialHandle,<br> const NewtonContact* contactlHandle)
</div>
<div class=SectionText>
Calculate the speed of this contact along the normal vector of the contact. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonContact</b>  contactlHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the contact data
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Contact speed. A positive value means the contact is repulsive.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetContactTangentSpeed"></a>
<a NAME="NewtonMaterialGetContactTangentSpeed"></a>
NewtonMaterialGetContactTangentSpeed
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonMaterialGetContactTangentSpeed</font>(<br> const NewtonMaterial* materialHandle,<br> const NewtonContact* contactlHandle,<br> int index)
</div>
<div class=SectionText>
Calculate the speed of this contact along the tangent vector of the contact. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonContact</b>  contactlHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the contact data.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> index
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to the tangent vector. This value can be 0 for primary tangent direction or 1 for the secondary tangent direction.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Contact tangent speed. 
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetContactPositionAndNormal"></a>
<a NAME="NewtonMaterialGetContactPositionAndNormal"></a>
NewtonMaterialGetContactPositionAndNormal
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialGetContactPositionAndNormal</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat* positPtr,<br> dFloat* normalPtr)
</div>
<div class=SectionText>
Get the contact position and normal in global space.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *positPtr,
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the contact position.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *normalPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the contact normal.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handle.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetContactForce"></a>
<a NAME="NewtonMaterialGetContactForce"></a>
NewtonMaterialGetContactForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialGetContactForce</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat* forcePtr)
</div>
<div class=SectionText>
Get the contact force vector in global space.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *forcePtr,
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the force vector in global space.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The contact force value is only valid when calculating resting contacts. This means if two bodies collide with 
   non zero relative velocity, the reaction force will be an impulse, which is not a reaction force, this will return zero vector. 
   this function will only return meaningful values when the colliding bodies are at rest.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetContactTangentDirections"></a>
<a NAME="NewtonMaterialGetContactTangentDirections"></a>
NewtonMaterialGetContactTangentDirections
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialGetContactTangentDirections</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat* dir0,<br> dFloat* dir1)
</div>
<div class=SectionText>
Get the contact tangent vector to the contact point. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *dir0
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the contact primary tangent vector.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *dir1
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the contact secondary tangent vector.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialGetBodyCollisionID"></a>
<a NAME="NewtonMaterialGetBodyCollisionID"></a>
NewtonMaterialGetBodyCollisionID
</h3>
<div class=Api>
unsigned <font class=ApiName>NewtonMaterialGetBodyCollisionID</font>(<br> const NewtonMaterial* material,<br> const NewtonBody* body)
</div>
<div class=SectionText>
Retrieve a user defined value stored with a convex collision primitive.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> a user defined value. Zero if not id was stored with the collision primitive.
  
<p>   <h4>Remarks</h4> the application can store an id with any collision primitive. This id can be used to identify what type of collision primitive generated a contact.
   This function can only be called from a contact callback,  
  
<p>   <h4>Remarks</h4> this function can only be called from a contact process callback. If called from contact callback begin this function will crash the application.
  
<p>   <h4>See also</h4> <a HREF="#NewtonConvexCollisionSetUserID">NewtonConvexCollisionSetUserID</a>, <a HREF="#NewtonCreateBox">NewtonCreateBox</a>, <a HREF="#NewtonCreateSphere">NewtonCreateSphere</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContactSoftness"></a>
<a NAME="NewtonMaterialSetContactSoftness"></a>
NewtonMaterialSetContactSoftness
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContactSoftness</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat softness)
</div>
<div class=SectionText>
Override the default softness value for the contact.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> softness
</td>
<td class=DefSep>-</td>
<td class=DefText>
softness value, must be positive.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>, <a HREF="#NewtonMaterialSetDefaultSoftness">NewtonMaterialSetDefaultSoftness</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContactElasticity"></a>
<a NAME="NewtonMaterialSetContactElasticity"></a>
NewtonMaterialSetContactElasticity
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContactElasticity</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat restitution)
</div>
<div class=SectionText>
Override the default elasticity (coefficient of restitution) value for the contact.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> restitution
</td>
<td class=DefSep>-</td>
<td class=DefText>
elasticity value, must be positive.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>, <a HREF="#NewtonMaterialSetDefaultElasticity">NewtonMaterialSetDefaultElasticity</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContactFrictionState"></a>
<a NAME="NewtonMaterialSetContactFrictionState"></a>
NewtonMaterialSetContactFrictionState
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContactFrictionState</font>(<br> const NewtonMaterial* materialHandle,<br> int state,<br> int index)
</div>
<div class=SectionText>
Enable or disable friction calculation for this contact.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> state*
</td>
<td class=DefSep>-</td>
<td class=DefText>
new state. 0 makes the contact frictionless along the index tangent vector.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> index
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to the tangent vector. 0 for primary tangent vector or 1 for the secondary tangent vector.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContactStaticFrictionCoef"></a>
<a NAME="NewtonMaterialSetContactStaticFrictionCoef"></a>
NewtonMaterialSetContactStaticFrictionCoef
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContactStaticFrictionCoef</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat coef,<br> int index)
</div>
<div class=SectionText>
Override the default value of the static coefficient of friction for this contact.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> coef
</td>
<td class=DefSep>-</td>
<td class=DefText>
static friction coeficient. Must be positive.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> index
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to the tangent vector. 0 for primary tangent vector or 1 for the secondary tangent vector.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> nothing
  
<p>   <h4>Remarks</h4> this function can only be called from a material callback event handler.
  
<p>   <h4>Remarks</h4> It is recommended that <b>coef</b> be set to a value lower or equal to 1.0, however because some synthetic materials
   can have hight than one coeficient of friction Newton allows for the coeficient of friction to be as high as 2.0.
  
<p>   <h4>Remarks</h4> the value <b>coef</b> will be clamped between the current kinetic friction and 2.0 (the maximum friction allowed).
   If the application wants to set a static friction lower than the current kinetic friction it must decrease the kinetic friction first.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>, <a HREF="#NewtonMaterialSetDefaultFriction">NewtonMaterialSetDefaultFriction</a>, <a HREF="#NewtonMaterialSetContactKineticFrictionCoef">NewtonMaterialSetContactKineticFrictionCoef</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContactKineticFrictionCoef"></a>
<a NAME="NewtonMaterialSetContactKineticFrictionCoef"></a>
NewtonMaterialSetContactKineticFrictionCoef
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContactKineticFrictionCoef</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat coef,<br> int index)
</div>
<div class=SectionText>
Override the default value of the kinetic coefficient of friction for this contact.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> coef
</td>
<td class=DefSep>-</td>
<td class=DefText>
static friction coefficient. Must be positive.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> index
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to the tangent vector. 0 for primary tangent vector or 1 for the secondary tangent vector.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
  
<p>   <h4>Remarks</h4> It is recommended that <b>coef</b> be set to a value lower or equal to 1.0, however because some synthetic materials
   can have hight than one coeficient of friction Newton allows for the coeficient of friction to be as high as 2.0.
  
<p>   <h4>Remarks</h4> the value <b>coef</b> will be clamped between 0.01f (minimum friction value) and that of the current static friction.
   If the application wants to set a kinetic friction higher than the current static friction it must increase the static friction first.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>, <a HREF="#NewtonMaterialSetDefaultFriction">NewtonMaterialSetDefaultFriction</a>, <a HREF="#NewtonMaterialSetContactStaticFrictionCoef">NewtonMaterialSetContactStaticFrictionCoef</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContactNormalAcceleration"></a>
<a NAME="NewtonMaterialSetContactNormalAcceleration"></a>
NewtonMaterialSetContactNormalAcceleration
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContactNormalAcceleration</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat accel)
</div>
<div class=SectionText>
Force the contact point to have a non-zero acceleration aligned this the contact normal.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> accel
</td>
<td class=DefSep>-</td>
<td class=DefText>
desired contact acceleration, Must be a positive value
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
  
<p>   <h4>Remarks</h4> This function can be used for spacial effects like implementing jump, of explosive contact in a call back.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContactTangentAcceleration"></a>
<a NAME="NewtonMaterialSetContactTangentAcceleration"></a>
NewtonMaterialSetContactTangentAcceleration
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContactTangentAcceleration</font>(<br> const NewtonMaterial* materialHandle,<br> dFloat accel,<br> int index)
</div>
<div class=SectionText>
Force the contact point to have a non-zero acceleration along the surface plane.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> accel
</td>
<td class=DefSep>-</td>
<td class=DefText>
desired contact acceleration.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> index
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to the tangent vector. 0 for primary tangent vector or 1 for the secondary tangent vector.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>, <a HREF="#NewtonMaterialContactRotateTangentDirections">NewtonMaterialContactRotateTangentDirections</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialSetContactNormalDirection"></a>
<a NAME="NewtonMaterialSetContactNormalDirection"></a>
NewtonMaterialSetContactNormalDirection
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialSetContactNormalDirection</font>(<br> const NewtonMaterial* materialHandle,<br> const dFloat* direction)
</div>
<div class=SectionText>
Set the new direction of the for this contact point.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *direction
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats holding the direction vector.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   This function changes the basis of the contact point to one where the contact normal is alinend to the new direction vector
   and the tangent direction are recalculated to be perpendicular to teh new contact normal.
  
<p>   <h4>Remarks</h4> In 99.9% of the cases the collision system can calculates a very good contact normal.
   however this algorithm that calculate the contact normal use as criteria the normal direction
   that will resolve the interpenetration with the least amount on motion. 
   There are situations however when this solution is not the best. Take for example a rolling
   ball over a texelated floor, when the ball is over a flat polygon, the contact normal is always
   perpendicular to the floor and pass by the origin of the sphere, however when the sphere is going 
   across two adjacent polygons, the contact normal is now perpendicular to the polygons edge and this does 
   not guarantee they it will pass bay the origin of the sphere, but we know that the best normal is always 
   the one passing by the origin of the sphere.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>, <a HREF="#NewtonMaterialContactRotateTangentDirections">NewtonMaterialContactRotateTangentDirections</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonMaterialContactRotateTangentDirections"></a>
<a NAME="NewtonMaterialContactRotateTangentDirections"></a>
NewtonMaterialContactRotateTangentDirections
</h3>
<div class=Api>
void <font class=ApiName>NewtonMaterialContactRotateTangentDirections</font>(<br> const NewtonMaterial* materialHandle,<br> const dFloat* alignVector)
</div>
<div class=SectionText>
Rotate the tangent direction of the contacts until the primary direction is aligned with the alignVector.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonMaterial</b> materialHandle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a material pair.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *alignVector
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats holding the aligning vector.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can only be called from a material callback event handler.
   This function rotates the tangent vectors of the contact point until the primary tangent vector and the align vector
   are perpendicular (ex. when the dot product between the primary tangent vector and the alignVector is 1.0). This 
   function can be used in conjunction with <a HREF="#NewtonMaterialSetContactTangentAcceleration">NewtonMaterialSetContactTangentAcceleration</a> in order to
   create special effects. For example, conveyor belts, cheap low lod vehicles, slippery surfaces, etc.
   
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialSetCollisionCallback">NewtonMaterialSetCollisionCallback</a>, <a HREF="#NewtonMaterialSetContactNormalDirection">NewtonMaterialSetContactNormalDirection</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Convex^collision^primitives^interface"></a>
<a NAME="Convex collision primitives interface"></a>
Convex collision primitives interface
</h3>
<div class=SectionText>

                                                                                                 
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateNull"></a>
<a NAME="NewtonCreateNull"></a>
NewtonCreateNull
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateNull</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Create a transparent collision primitive.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the collision object.
  
<p>   <h4>Remarks</h4> Some times the application needs to create helper rigid bodies that will never collide with other bodies,
   for example the neck of a rag doll, or an internal part of an articulated structure. This can be done by using the material system
   but it too much work and it will increase unnecessarily the material count, and therefore the project complexity. The Null collision  
   is a collision object that satisfy all this conditions without having to change the engine philosophy.
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the objects.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used by the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateBox"></a>
<a NAME="NewtonCreateBox"></a>
NewtonCreateBox
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateBox</font>(<br> const NewtonWorld* newtonWorld,<br> dFloat dx,<br> dFloat dy,<br> dFloat dz,<br> const dFloat *offsetMatrix)
</div>
<div class=SectionText>
Create a box primitive for collision.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> dx
</td>
<td class=DefSep>-</td>
<td class=DefText>
box side one x dimension.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> dy
</td>
<td class=DefSep>-</td>
<td class=DefText>
box side one y dimension.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> dz
</td>
<td class=DefSep>-</td>
<td class=DefText>
box side one z dimension.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *offsetMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of the box relative to the body. If this parameter is NULL, then the primitive is centered at the origin of the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the box
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used be the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>, <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateSphere"></a>
<a NAME="NewtonCreateSphere"></a>
NewtonCreateSphere
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateSphere</font>(<br> const NewtonWorld* newtonWorld,<br> dFloat radiusX,<br> dFloat radiusY,<br> dFloat radiusZ,<br> const dFloat *offsetMatrix)
</div>
<div class=SectionText>
Create a generalized ellipsoid primitive..
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> radiusX
</td>
<td class=DefSep>-</td>
<td class=DefText>
sphere radius along x axis.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> radiusY
</td>
<td class=DefSep>-</td>
<td class=DefText>
sphere radius along x axis.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> radiusZ
</td>
<td class=DefSep>-</td>
<td class=DefText>
sphere radius along x axis.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *offsetMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of the sphere relative to the body. If this parameter is NULL then the sphere is centered at the origin of the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the generalized sphere.
  
<p>   <h4>Remarks</h4> Sphere collision are generalized ellipsoids, the application can create many different kind of objects by just playing with dimensions of the radius.
   for example to make a sphere set all tree radius to the same value, to make a ellipse of revolution just set two of the tree radius to the same value.
  
<p>   <h4>Remarks</h4> General ellipsoids are very good hull geometries to represent the outer shell of avatars in a game. 
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used be the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>, <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateCone"></a>
<a NAME="NewtonCreateCone"></a>
NewtonCreateCone
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateCone</font>(<br> const NewtonWorld* newtonWorld,<br> dFloat radius,<br> dFloat height,<br> const dFloat *offsetMatrix)
</div>
<div class=SectionText>
Create a cone primitive for collision.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> radius
</td>
<td class=DefSep>-</td>
<td class=DefText>
cone radius at the base.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> height
</td>
<td class=DefSep>-</td>
<td class=DefText>
cone height along the x local axis from base to tip.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *offsetMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of the box relative to the body. If this parameter is NULL, then the primitive is centered at the origin of the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the box
   
<p>   <h4>Remark</h4> the cone height must equal of larger than the sum of the cap radius. if this is not the case the height will be clamped the 2 * radius.
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used be the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>, <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateCapsule"></a>
<a NAME="NewtonCreateCapsule"></a>
NewtonCreateCapsule
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateCapsule</font>(<br> const NewtonWorld* newtonWorld,<br> dFloat radius,<br> dFloat height,<br> const dFloat *offsetMatrix)
</div>
<div class=SectionText>
Create a capsule primitive for collision.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> radius
</td>
<td class=DefSep>-</td>
<td class=DefText>
capsule radius at the base.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> height
</td>
<td class=DefSep>-</td>
<td class=DefText>
capsule height along the x local axis from tip to tip.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *offsetMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of the box relative to the body. If this parameter is NULL, then the primitive is centered at the origin of the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the box
   
<p>   <h4>Remark</h4> the capsule height must equal of larger than the sum of the cap radius. If this is not the case the height will be clamped the 2 * radius.
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used be the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>, <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateCylinder"></a>
<a NAME="NewtonCreateCylinder"></a>
NewtonCreateCylinder
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateCylinder</font>(<br> const NewtonWorld* newtonWorld,<br> dFloat radius,<br> dFloat height,<br> const dFloat *offsetMatrix)
</div>
<div class=SectionText>
Create a cylinder primitive for collision.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> radius
</td>
<td class=DefSep>-</td>
<td class=DefText>
cylinder radius at the base.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> height
</td>
<td class=DefSep>-</td>
<td class=DefText>
cylinder height along the x local axis.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *offsetMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of the box relative to the body. If this parameter is NULL, then the primitive is centered at the origin of the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the box
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used be the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>, <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateChamferCylinder"></a>
<a NAME="NewtonCreateChamferCylinder"></a>
NewtonCreateChamferCylinder
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateChamferCylinder</font>(<br> const NewtonWorld* newtonWorld,<br> dFloat radius,<br> dFloat height,<br> const dFloat *offsetMatrix)
</div>
<div class=SectionText>
Create a ChamferCylinder primitive for collision.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> radius
</td>
<td class=DefSep>-</td>
<td class=DefText>
ChamferCylinder radius at the base.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> height
</td>
<td class=DefSep>-</td>
<td class=DefText>
ChamferCylinder height along the x local axis.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *offsetMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of the box relative to the body. If this parameter is NULL, then the primitive is centered at the origin of the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the box
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used be the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>, <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateConvexHull"></a>
<a NAME="NewtonCreateConvexHull"></a>
NewtonCreateConvexHull
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateConvexHull</font>(<br> const NewtonWorld* newtonWorld,<br> int count,<br> dFloat* vertexCloud,<br> int strideInBytes,<br> dFloat *offsetMatrix)
</div>
<div class=SectionText>
Create a ConvexHull primitive for collision from a cloud of points.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> count
</td>
<td class=DefSep>-</td>
<td class=DefText>
number of consecutive point to follow must be at least 4.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> vertexCloud
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of point.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> strideInBytes
</td>
<td class=DefSep>-</td>
<td class=DefText>
vertex size in bytes, must be at least 12.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *offsetMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of the box relative to the body. If this parameter is NULL, then the primitive is centered at the origin of the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the box
  
<p>   <h4>Remarks</h4> Convex hulls are the solution to collision primitive that can not be easily represented by and implicit solid.
   The implicit solid primitives (spheres, cubes, cylinders, capsules, cones, etc.), have constant time complexity for contact calculation
   and are also extremely efficient on memory usage, therefore the application get perfect smooth behavior.
   However for cases where the shape is too difficult or a polygonal representation is desired convex hulls are the ultimate solution. 
   For example it is a mistake to model a 10000 point sphere as a convex hull, when the perfect sphere is available.
  
<p>   <h4>Remarks</h4> There is not upper limit as to how many vertex the application can pass to Newton to make a hull shape, 
   however for performance and memory usage concern it is the application responsibility to keep the max vertex at the possible minimum. 
   The minimum number of vertex should be equal or larger than 4 and it is the application responsibility that the points are part of a solid geometry. 
   Unpredictable results will occur if all points happen to be collinear or coplanar.  
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used be the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>, <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateConvexHullModifier"></a>
<a NAME="NewtonCreateConvexHullModifier"></a>
NewtonCreateConvexHullModifier
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateConvexHullModifier</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonCollision* convexHullCollision)
</div>
<div class=SectionText>
Create a collision modifier for any convex collision part.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
   <b>NewtonCollision</b> convexHullCollision.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Pointer to the collision modifier
  
<p>   <h4>Remarks</h4> The matrix should be arranged in row-major order (this is the way directX stores matrices).
   a collision modifier can take any type of transformation matrix, as long as the matrix can be invertible by straight
   Gaussian elimination process. Typical uses are non-uniform scaling, translation and skewing.
  
<p>   <h4>Remarks</h4> Collision modifier can be used by the application to achieve effects like animating collision geometry at run time, 
   however care must taken as animation of a collision primitive could result in unwanted penetrations. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>, <a HREF="#NewtonConvexHullModifierSetMatrix">NewtonConvexHullModifierSetMatrix</a>, <a HREF="#NewtonConvexHullModifierGetMatrix">NewtonConvexHullModifierGetMatrix</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConvexHullModifierGetMatrix"></a>
<a NAME="NewtonConvexHullModifierGetMatrix"></a>
NewtonConvexHullModifierGetMatrix
</h3>
<div class=SectionText>
Get the transformation matrix of a convex hull modifier collision.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *convexHullModifier
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *matrixPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the global matrix of the collision modifier.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The matrix should be arranged in row-major order (this is the way directX stores matrices).
   a collision modifier can take any type of transformation matrix, as long as the matrix can be invertible by straight
   Gaussian elimination process. Typical uses are non-uniform scaling, translation and skewing.
  
<p>   <h4>Remarks</h4> Collision modifier can be used by the application to achieve effects like animating collision geometry at run time, 
   however care must taken as animation of a collision primitive could result into unwanted penetrations. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>, <a HREF="#NewtonConvexHullModifierSetMatrix">NewtonConvexHullModifierSetMatrix</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConvexHullModifierSetMatrix"></a>
<a NAME="NewtonConvexHullModifierSetMatrix"></a>
NewtonConvexHullModifierSetMatrix
</h3>
<div class=Api>
void <font class=ApiName>NewtonConvexHullModifierSetMatrix</font>(<br> const NewtonCollision* convexHullModifier,<br> const dFloat* matrixPtr)
</div>
<div class=SectionText>
Set the transformation matrix of a convex hull modifier collision.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *convexHullModifier
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the global matrix of the collision modifier.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The matrix should be arranged in row-major order (this is the way directX stores matrices).
   a collision modifier can take any type of transformation matrix, as long as the matrix can be invertible by straight
   Gaussian elimination process. Typical uses are non-uniform scaling, translation and skewing.
  
<p>   <h4>Remarks</h4> Collision modifier can be used by the application to achieve effects like animating collision geometry at run time, 
   however care must taken as animation of a collision primitive could result into unwanted penetrations. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonCreateConvexHullModifier">NewtonCreateConvexHullModifier</a>, <a HREF="#NewtonConvexHullModifierGetMatrix">NewtonConvexHullModifierGetMatrix</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateCompoundCollision"></a>
<a NAME="NewtonCreateCompoundCollision"></a>
NewtonCreateCompoundCollision
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateCompoundCollision</font>(<br> const NewtonWorld* newtonWorld,<br> int count,<br> NewtonCollision* const collisionPrimitiveArray[])
</div>
<div class=SectionText>
Create a container to hold an array of convex collision primitives. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> count
</td>
<td class=DefSep>-</td>
<td class=DefText>
number of primitives in the array.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> **collisionPrimitiveArray
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of convex collision primitives. This array must be filled with convex collision primitives before this function is called.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the compound collision.
  
<p>   <h4>Remarks</h4> Compound collision primitives can only be made of convex collision primitives and they can not contain compound collision. Therefore they are treated as convex primitives.
  
<p>   <h4>Remarks</h4> Compound collision primitives are treated as instance collision objects that can not shared by multiples rigid bodies.
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConvexCollisionSetUserID"></a>
<a NAME="NewtonConvexCollisionSetUserID"></a>
NewtonConvexCollisionSetUserID
</h3>
<div class=Api>
void <font class=ApiName>NewtonConvexCollisionSetUserID</font>(<br> const NewtonCollision* convexCollision,<br> unsigned id)
</div>
<div class=SectionText>
Store a user defined value with a convex collision primitive.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> convexCollision
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to a convex collision primitive.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>unsigned</b> id
</td>
<td class=DefSep>-</td>
<td class=DefText>
value to store with the collision primitive.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> nothing
  
<p>   <h4>Remarks</h4> the application can store an id with any collision primitive. This id can be used to identify what type of collision primitive generated a contact.
  
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialGetBodyCollisionID">NewtonMaterialGetBodyCollisionID</a>, <a HREF="#NewtonConvexCollisionGetUserID">NewtonConvexCollisionGetUserID</a>, <a HREF="#NewtonCreateBox">NewtonCreateBox</a>, <a HREF="#NewtonCreateSphere">NewtonCreateSphere</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConvexCollisionGetUserID"></a>
<a NAME="NewtonConvexCollisionGetUserID"></a>
NewtonConvexCollisionGetUserID
</h3>
<div class=Api>
unsigned <font class=ApiName>NewtonConvexCollisionGetUserID</font>(const NewtonCollision* convexCollision)
</div>
<div class=SectionText>
Return a user define value with a convex collision primitive.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> convexCollision
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to a convex collision primitive.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> user id
  
<p>   <h4>Remarks</h4> the application can store an id with any collision primitive. This id can be used to identify what type of collision primitive generated a contact.
  
<p>   <h4>See also</h4> <a HREF="#NewtonMaterialGetBodyCollisionID">NewtonMaterialGetBodyCollisionID</a>, NewtonMaterialGetBodyCollisionID, <a HREF="#NewtonCreateBox">NewtonCreateBox</a>, <a HREF="#NewtonCreateSphere">NewtonCreateSphere</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConvexCollisionCalculateVolume"></a>
<a NAME="NewtonConvexCollisionCalculateVolume"></a>
NewtonConvexCollisionCalculateVolume
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonConvexCollisionCalculateVolume</font>(const NewtonCollision* convexCollision)
</div>
<div class=SectionText>
calculate the total volume defined by a convex collision geometry.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *convexCollision
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the collision.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> collision geometry volume. This function will return zero if the body collision geometry is no convex.
  
<p>   <h4>Remarks</h4> The total volume calculated by the function is only an approximation of the ideal volume. This is not an error, it is a fact resulting from the polygonal representation of convex solids.
  
<p>   <h4>Remarks</h4> This function can be used to assist the application in calibrating features like fluid density weigh factor when calibrating buoyancy forces for more realistic result.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyAddBuoyancyForce">NewtonBodyAddBuoyancyForce</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConvexCollisionCalculateInertialMatrix"></a>
<a NAME="NewtonConvexCollisionCalculateInertialMatrix"></a>
NewtonConvexCollisionCalculateInertialMatrix
</h3>
<div class=Api>
void <font class=ApiName>NewtonConvexCollisionCalculateInertialMatrix</font>(<br> const NewtonCollision* convexCollision,<br> dFloat* inertia,<br> dFloat* origin)
</div>
<div class=SectionText>
Calculate the three principal axis and the the values of the inertia matrix of a convex collision objects.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> convexCollision
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to a convex collision primitive.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *inertia
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 floats to hold the values of the principal inertia.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *origin
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 floats to hold the values of the center of mass for the principal inertia.
</td>
</tr>
</table>

<p>   
   <h4>Remarks</h4> This function calculate a general inertial matrix for arbitrary convex collision including compound collisions.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetMassMatrix">NewtonBodySetMassMatrix</a>, <a HREF="#NewtonBodyGetMassMatrix">NewtonBodyGetMassMatrix</a>, <a HREF="#NewtonBodySetCentreOfMass">NewtonBodySetCentreOfMass</a>, <a HREF="#NewtonBodyGetCentreOfMass">NewtonBodyGetCentreOfMass</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Complex^collision^primitives^interface"></a>
<a NAME="Complex collision primitives interface"></a>
Complex collision primitives interface
</h3>
<div class=SectionText>

                                                                                                 
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateUserMeshCollision"></a>
<a NAME="NewtonCreateUserMeshCollision"></a>
NewtonCreateUserMeshCollision
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateUserMeshCollision</font>(<br> 
	const NewtonWorld* newtonWorld,<br> 
	const dFloat *minBox,<br> 
	const dFloat *maxBox,<br> 
	void *userData,<br>
	NewtonUserMeshCollisionCollideCallback collideCallback,<br> 
	NewtonUserMeshCollisionRayHitCallback rayHitCallBack,<br>
	NewtonUserMeshCollisionDestroyCallback destroyCallback)
</div>
<div class=SectionText>
Create a complex collision geometry to be controlled by the application.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *minBox
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold minimum value for the box relative to the collision.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *maxBox
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold maximum value for the box relative to the collision.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userData
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to user data to be used as context for event callback.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonUserMeshCollisionCollideCallback</b> collideCallback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an event function for providing Newton with the polygon inside a given box region.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonUserMeshCollisionRayHitCallback</b> rayHitCallBack
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an event function for providing Newton with ray intersection information.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonUserMeshCollisionDestroyCallback</b> destroyCallback	
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an event function for destroying any data allocated for use by the application.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the user collision.
  
<p>   <h4>Remarks</h4> <b>UserMeshCollision</b> provides the application with a method of overloading the built-in collision system for background objects.
   UserMeshCollision can be used for implementing collisions with height maps, collisions with BSP, and any other collision structure the application
   supports and wishes to preserve.
   However, <b>UserMeshCollision</b> can not take advantage of the efficient and sophisticated algorithms and data structures of the 
   built-in <b>TreeCollision</b>. We suggest you experiment with both methods and use the method best suited to your situation.
  
<p>   <h4>Remarks</h4> When a <b>UserMeshCollision</b> is assigned to a body, the mass of the body is ignored in all dynamics calculations. 
   This make the body behave as a static body.
  
<p>   <h4>Remarks</h4> The most significant bit of a triangle index list is use to indite to Newton that edge between
   that index and next index is not part of collision calculation. 
   The application can use this feature to mark concave and coplanar shared edges as non collidables.
   for example is two triangles has indices 1, 2, 3  and 3, 2, 4 respective, if the two triangle are coplanar, then the application can mark edge 2, 3 as:
   1, 2 | 0x80000000, 3 | 0x80000000 for triangle 1 and 3 | 0x80000000, 2 | 0x80000000, 4 for the second triangle.
   these feature greatly enhances the quality of contact generation meshes with flat and concave faces. 
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used be the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateTreeCollision"></a>
<a NAME="NewtonCreateTreeCollision"></a>
NewtonCreateTreeCollision
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateTreeCollision</font>(<br> const NewtonWorld* newtonWorld,<br> NewtonTreeCollisionCallback userCallback)
</div>
<div class=SectionText>
Create an empty complex collision geometry tree. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>    
<tr class=Def>
<td class=Def>
NewtonTreeCollisionCallback *userCallback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an event function to call before Newton evaluates the polygons colliding with a body. This parameter can be NULL.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the collision tree.
  
<p>   <h4>Remarks</h4> <b>TreeCollision</b> is the preferred method within Newton for collision with polygonal meshes of arbitrary complexity.
   The mesh must be made of flat non-intersecting polygons, but they do not explicitly need to be triangles.
   <b>TreeCollision</b> can be serialized by the application to/from an arbitrary storage device. 
  
<p>   <h4>Remarks</h4> When a <b>TreeCollision</b> is assigned to a body the mass of the body is ignored in all dynamics calculations. 
   This makes the body behave as a static body.
  
<p>   <h4>Remarks</h4> Collision primitives are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.
   Collision primitives can be reused with more than one body. This will reduce the amount of memory used by the engine, as well
   as speed up some calculations.
  
<p>   <h4>See also</h4> <a HREF="#NewtonTreeCollisionBeginBuild">NewtonTreeCollisionBeginBuild</a>, <a HREF="#NewtonTreeCollisionAddFace">NewtonTreeCollisionAddFace</a>, <a HREF="#NewtonTreeCollisionEndBuild">NewtonTreeCollisionEndBuild</a>, <a HREF="#NewtonTreeCollisionSerialize">NewtonTreeCollisionSerialize</a>, <a HREF="#NewtonCreateTreeCollisionFromSerialization">NewtonCreateTreeCollisionFromSerialization</a>, <a HREF="#NewtonTreeCollisionGetFaceAtribute">NewtonTreeCollisionGetFaceAtribute</a>, <a HREF="#NewtonTreeCollisionSetFaceAtribute">NewtonTreeCollisionSetFaceAtribute</a>, <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonTreeCollisionBeginBuild"></a>
<a NAME="NewtonTreeCollisionBeginBuild"></a>
NewtonTreeCollisionBeginBuild
</h3>
<div class=Api>
void <font class=ApiName>NewtonTreeCollisionBeginBuild</font>(const NewtonCollision* treeCollision)
</div>
<div class=SectionText>
Prepare a <b>TreeCollision</b> to begin to accept the polygons that comprise the collision mesh.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>See also</h4> <a HREF="#NewtonTreeCollisionAddFace">NewtonTreeCollisionAddFace</a>, <a HREF="#NewtonTreeCollisionEndBuild">NewtonTreeCollisionEndBuild</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonTreeCollisionAddFace"></a>
<a NAME="NewtonTreeCollisionAddFace"></a>
NewtonTreeCollisionAddFace
</h3>
<div class=Api>
void <font class=ApiName>NewtonTreeCollisionAddFace</font>(<br> 
	const NewtonCollision* treeCollision,<br>
	int vertexCount,<br> 
	const dFloat* vertexPtr,<br> 
	int strideInBytes,<br> 
	int faceAttribute)
</div>
<div class=SectionText>
Add an individual polygon to a <b>TreeCollision</b>.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> vertexCount
</td>
<td class=DefSep>-</td>
<td class=DefText>
number of vertex in <b>vertexPtr</b>
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *vertexPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of vertex. The vertex should consist of at least 3 floats each.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> strideInBytes
</td>
<td class=DefSep>-</td>
<td class=DefText>
size of each vertex in bytes. This value should be 12 or larger.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> faceAttribute
</td>
<td class=DefSep>-</td>
<td class=DefText>
id that identifies the polygon. The application can use this value to customize the behavior of the collision geometry.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> After the call to <b>NewtonTreeCollisionBeginBuild</b> the <b>TreeCollision</b> is ready to accept polygons. The application should iterate
   through the application's mesh, adding the mesh polygons to the <b>TreeCollision</b> one at a time.
   The polygons must be flat and non-self intersecting.
  
<p>   <h4>See also</h4> NewtonTreeCollisionAddFace, <a HREF="#NewtonTreeCollisionEndBuild">NewtonTreeCollisionEndBuild</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonTreeCollisionEndBuild"></a>
<a NAME="NewtonTreeCollisionEndBuild"></a>
NewtonTreeCollisionEndBuild
</h3>
<div class=Api>
void <font class=ApiName>NewtonTreeCollisionEndBuild</font>(<br> const NewtonCollision* treeCollision,<br> int optimize)
</div>
<div class=SectionText>
Finalize the construction of the polygonal mesh.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> optimize
</td>
<td class=DefSep>-</td>
<td class=DefText>
flag that indicates to Newton whether it should optimize this mesh. Set to 1 to optimize the mesh, otherwise 0.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> After the application has finished adding polygons to the <b>TreeCollision</b>, it must call this function to finalize the construction of the collision mesh.
   If concave polygons are added to the <b>TreeCollision</b>, the application must call this function with the parameter <b>optimize</b> set to 1.
   With the <b>optimize</b> parameter set to 1, Newton will optimize the collision mesh by removing non essential edges from adjacent flat polygons.
   Newton will not change the topology of the mesh but significantly reduces the number of polygons in the mesh. The reduction factor of the number of polygons in the mesh depends upon the irregularity of the mesh topology.
   A reduction factor of 1.5 to 2.0 is common. 
   Calling this function with the parameter <b>optimize</b> set to zero, will leave the mesh geometry unaltered.
  
<p>   <h4>See also</h4> <a HREF="#NewtonTreeCollisionAddFace">NewtonTreeCollisionAddFace</a>, NewtonTreeCollisionEndBuild


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonTreeCollisionSerialize"></a>
<a NAME="NewtonTreeCollisionSerialize"></a>
NewtonTreeCollisionSerialize
</h3>
<div class=Api>
void <font class=ApiName>NewtonTreeCollisionSerialize</font>(<br> const NewtonCollision* treeCollision,<br> NewtonSerialize callback,<br> void* serializeHandle)
</div>
<div class=SectionText>
Serialize a <b>TreeCollision</b>.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonSerialize</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the event function that will do the serialization.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *serializeHandle	
</td>
<td class=DefSep>-</td>
<td class=DefText>
user data that will be passed to the <b>NewtonSerialize</b> callback.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> Small and medium size <b>TreeCollision</b> objects (under 50000 polygons) can be constructed at application startup without significant processing overhead.
   However, for very large polygons sets (over 50000 polygons) it is recommended that the application use <b>NewtonCreateTreeCollision</b>
   in an off-line tool. Then the application can call this function to store the <b>TreeCollision</b> to a file or 
   any file packer system the application is using. At run time the application can use the function <b>NewtonCreateTreeCollisionFromSerialization</b> 
   to create and load a pre-made <b>TreeCollision</b>
  
<p>   <h4>See also</h4> <a HREF="#NewtonCreateTreeCollisionFromSerialization">NewtonCreateTreeCollisionFromSerialization</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateTreeCollisionFromSerialization"></a>
<a NAME="NewtonCreateTreeCollisionFromSerialization"></a>
NewtonCreateTreeCollisionFromSerialization
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonCreateTreeCollisionFromSerialization</font>(<br> 
	const NewtonWorld* newtonWorld,<br> 
	NewtonTreeCollisionCallback userCallback,<br>
	NewtonDeserialize deserializeFunction,<br> 
	void* serializeHandle)
</div>
<div class=SectionText>
Create a tree collision and load the polygon mesh via a serialization function.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>    
<tr class=Def>
<td class=Def>
NewtonTreeCollisionCallback *userCallback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an event function to call before Newton is begins collecting polygons that are colliding with a body. This parameter can be NULL.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonSerialize</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the callback function that will handle the serialization.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userData	
</td>
<td class=DefSep>-</td>
<td class=DefText>
user data that will be passed as the argument to <b>NewtonSerialize</b> callback.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> Small and medium size <b>TreeCollision</b> objects (under 50000 polygons) can be constructed at application startup without significant processing overhead.
   However, for very large polygons sets (over 50000 polygons) it is recommended that the application use <b>NewtonCreateTreeCollision</b> 
   in an off-line tool. Then the application can call this function to store the <b>TreeCollision</b> to a file or 
   any file packer system the application is using. At run time the application can use the function <b>NewtonCreateTreeCollisionFromSerialization</b> 
   to create and load a pre-made <b>TreeCollision</b>
  
<p>   <h4>See also</h4> <a HREF="#NewtonTreeCollisionSerialize">NewtonTreeCollisionSerialize</a>, <a HREF="#NewtonReleaseCollision">NewtonReleaseCollision</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonTreeCollisionGetFaceAtribute"></a>
<a NAME="NewtonTreeCollisionGetFaceAtribute"></a>
NewtonTreeCollisionGetFaceAtribute
</h3>
<div class=Api>
int <font class=ApiName>NewtonTreeCollisionGetFaceAtribute</font>(<br> const NewtonCollision* treeCollision,<br> const int* faceIndexArray)
</div>
<div class=SectionText>
Get the user defined collision attributes stored with each face of the collision mesh.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const int</b> *faceIndexArray
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the face index list passed to the function <b>NewtonTreeCollisionCallback userCallback</b>
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> User id of the face.
  
<p>   <h4>Remarks</h4> This function is used to obtain the user data stored in faces of the collision geometry.
   The application can use this user data to achieve per polygon material behavior in large static collision meshes.
  
<p>   <h4>See also</h4> <a HREF="#NewtonTreeCollisionSetFaceAtribute">NewtonTreeCollisionSetFaceAtribute</a>, <a HREF="#NewtonCreateTreeCollision">NewtonCreateTreeCollision</a>, <a HREF="#NewtonCreateTreeCollisionFromSerialization">NewtonCreateTreeCollisionFromSerialization</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonTreeCollisionSetFaceAtribute"></a>
<a NAME="NewtonTreeCollisionSetFaceAtribute"></a>
NewtonTreeCollisionSetFaceAtribute
</h3>
<div class=Api>
void <font class=ApiName>NewtonTreeCollisionSetFaceAtribute</font>(<br> const NewtonCollision* treeCollision,<br> const int* faceIndexArray,<br> int attribute)
</div>
<div class=SectionText>
Change the user defined collision attribute stored with faces of the collision mesh.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const int</b> *faceIndexArray
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the face index list passed to the function <b>NewtonTreeCollisionCallback userCallback</b>
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> attribute
</td>
<td class=DefSep>-</td>
<td class=DefText>
value of the user defined attribute to be stored with the face.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> User id of the face.
  
<p>   <h4>Remarks</h4> This function is used to obtain the user data stored in faces of the collision geometry.
   The application can use this user data to achieve per polygon material behavior in large static collision meshes.
   By changing the value of this user data the application can achieve modifiable surface behavior with the collision geometry.
   For example, in a driving game, the surface of a polygon that represents the street can changed from pavement to oily or wet after
   some collision event occurs.
  
<p>   <h4>See also</h4> <a HREF="#NewtonTreeCollisionGetFaceAtribute">NewtonTreeCollisionGetFaceAtribute</a>, <a HREF="#NewtonCreateTreeCollision">NewtonCreateTreeCollision</a>, <a HREF="#NewtonCreateTreeCollisionFromSerialization">NewtonCreateTreeCollisionFromSerialization</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Generic^collision^library^functions"></a>
<a NAME="Generic collision library functions"></a>
Generic collision library functions
</h3>
<div class=SectionText>

                                                                                                 
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCollisionPointDistance"></a>
<a NAME="NewtonCollisionPointDistance"></a>
NewtonCollisionPointDistance
</h3>
<div class=Api>
int <font class=ApiName>NewtonCollisionPointDistance</font>(<br> const NewtonWorld* newtonWorld,<br> const float *point,<br>
								 const NewtonCollision* collision,<br> const dFloat* matrix,<br>
								 dFloat* contact,<br> dFloat* normal)
</div>
<div class=SectionText>
Calculate the closest point between a point and convex collision primitive.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *point
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 floats representing the origin.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collision
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to collision primitive.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of collision primitiveA.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *contact
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 floats to contain the closest point to collisioA.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *normal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 floats to contain the separating vector normal.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> one if the two bodies are disjoint and the closest point could be found, 
   zero if the point is inside the convex primitive.
  
<p>   <h4>Remarks</h4> This function can be used as a low-level building block for a stand-alone collision system. 
   Applications that have already there own physics system, and only want and quick and fast collision solution, 
   can use Newton advanced collision engine as the low level collision detection part. 
   To do this the application only needs to initialize Newton, create the collision primitives at application discretion, 
   and just call this function when the objects are in close proximity. Applications using Newton as a collision system 
   only, are responsible for implementing their own broad phase collision determination, based on any high level tree structure. 
   Also the application should implement their own trivial aabb test, before calling this function .
  
<p>   <h4>Remarks</h4> the current implementation of this function do work on collision trees, or user define collision.
  
<p>   <h4>See also</h4> <a HREF="#NewtonCollisionCollideContinue">NewtonCollisionCollideContinue</a>, <a HREF="#NewtonCollisionClosestPoint">NewtonCollisionClosestPoint</a>, <a HREF="#NewtonCollisionCollide">NewtonCollisionCollide</a>, <a HREF="#NewtonCollisionRayCast">NewtonCollisionRayCast</a>, <a HREF="#NewtonCollisionCalculateAABB">NewtonCollisionCalculateAABB</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCollisionClosestPoint"></a>
<a NAME="NewtonCollisionClosestPoint"></a>
NewtonCollisionClosestPoint
</h3>
<div class=Api>
int <font class=ApiName>NewtonCollisionClosestPoint</font>(<br> const NewtonWorld* newtonWorld,<br> 
								const NewtonCollision* collisionA,<br> const dFloat* matrixA,<br>
								const NewtonCollision* collisionB,<br> const dFloat* matrixB,<br>
								dFloat* contactA,<br> dFloat* contactB,<br> dFloat* normalAB)
</div>
<div class=SectionText>
Calculate the closest points between two disjoint convex collision primitive.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to collision primitive A.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of collision primitiveA.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to collision primitive B.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of collision primitiveB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *contactA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 floats to contain the closest point to collisionA.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *contactB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 floats to contain the closest point to collisionB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *normalAB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 floats to contain the separating vector normal.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> one if the tow bodies are disjoint and he closest point could be found, 
   zero if the two collision primitives are intersecting.
  
<p>   <h4>Remarks</h4> This function can be used as a low-level building block for a stand-alone collision system. 
   Applications that have already there own physics system, and only want and quick and fast collision solution, 
   can use Newton advanced collision engine as the low level collision detection part. 
   To do this the application only needs to initialize Newton, create the collision primitives at application discretion, 
   and just call this function when the objects are in close proximity. Applications using Newton as a collision system 
   only, are responsible for implementing their own broad phase collision determination, based on any high level tree structure. 
   Also the application should implement their own trivial aabb test, before calling this function .
  
<p>   <h4>Remarks</h4> the current implementation of this function does not work on collision trees, or user define collision.
  
<p>   <h4>See also</h4> <a HREF="#NewtonCollisionCollideContinue">NewtonCollisionCollideContinue</a>, <a HREF="#NewtonCollisionPointDistance">NewtonCollisionPointDistance</a>, <a HREF="#NewtonCollisionCollide">NewtonCollisionCollide</a>, <a HREF="#NewtonCollisionRayCast">NewtonCollisionRayCast</a>, <a HREF="#NewtonCollisionCalculateAABB">NewtonCollisionCalculateAABB</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCollisionCollide"></a>
<a NAME="NewtonCollisionCollide"></a>
NewtonCollisionCollide
</h3>
<div class=Api>
int <font class=ApiName>NewtonCollisionCollide</font>(<br> const NewtonWorld* newtonWorld,<br> int maxSize,<br>
						   const NewtonCollision* collisionA,<br> const dFloat* matrixA,<br>
						   const NewtonCollision* collisionB,<br> const dFloat* matrixB,<br>
						   dFloat* contacts,<br> dFloat* normals,<br> dFloat* penetration)
</div>
<div class=SectionText>
Calculate contact points between two collision primitive.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> maxSize
</td>
<td class=DefSep>-</td>
<td class=DefText>
size of maximum number of elements in contacts, normals, and penetration.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to collision primitive A.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of collision primitiveA.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to collision primitive B.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of collision primitiveB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *contacts
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 times maxSize floats to contain the collision contact points.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *normals
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 times maxSize floats to contain the collision contact normals.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *penetration
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least maxSize floats to contain the collision penetration at each contact.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> the number of contact points.
  
<p>   <h4>Remarks</h4> This function can be used as a low-level building block for a stand-alone collision system. 
   Applications that have already there own physics system, and only want and quick and fast collision solution, 
   can use Newton advanced collision engine as the low level collision detection part. 
   To do this the application only needs to initialize Newton, create the collision primitives at application discretion, 
   and just call this function when the objects are in close proximity. Applications using Newton as a collision system 
   only, are responsible for implementing their own broad phase collision determination, based on any high level tree structure. 
   Also the application should implement their own trivial aabb test, before calling this function .
  
<p>   <h4>See also</h4> <a HREF="#NewtonCollisionCollideContinue">NewtonCollisionCollideContinue</a>, <a HREF="#NewtonCollisionClosestPoint">NewtonCollisionClosestPoint</a>, <a HREF="#NewtonCollisionPointDistance">NewtonCollisionPointDistance</a>, <a HREF="#NewtonCollisionRayCast">NewtonCollisionRayCast</a>, <a HREF="#NewtonCollisionCalculateAABB">NewtonCollisionCalculateAABB</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCollisionCollideContinue"></a>
<a NAME="NewtonCollisionCollideContinue"></a>
NewtonCollisionCollideContinue
</h3>
<div class=Api>
int <font class=ApiName>NewtonCollisionCollideContinue</font>(<br> const NewtonWorld* newtonWorld,<br> int maxSize,<br> const dFloat timestep,<br> 
		const NewtonCollision* collisionA,<br> const dFloat* matrixA,<br> const dFloat* velocA,<br> const dFloat* omegaA,<br> 
		const NewtonCollision* collisionB,<br> const dFloat* matrixB,<br> const dFloat* velocB,<br> const dFloat* omegaB,<br> 
		dFloat* timeOfImpact,<br> dFloat* contacts,<br> dFloat* normals,<br> dFloat* penetration)
</div>
<div class=SectionText>
Calculate time of impact of impact and contact points between two collision primitive.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> maxSize
</td>
<td class=DefSep>-</td>
<td class=DefText>
size of maximum number of elements in contacts, normals, and penetration.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> timestep
</td>
<td class=DefSep>-</td>
<td class=DefText>
maximum time interval consided for the continue collision claculation.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to collision primitive A.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of collision primitiveA.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *velocA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 times maxSize floats containing the linear velocity of collision primitiveA.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *omegaA
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 times maxSize floats containing the angular velocity of collision primitiveA.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to collision primitive B.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix of collision primitiveB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *velocB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 times maxSize floats containing the linear velocity of collision primitiveB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *omegaB
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 times maxSize floats containing the angular velocity of collision primitiveB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *timeOfImpact
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to least 1 float variable to contain the time of the intersection.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *contacts
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 times maxSize floats to contain the collision contact points.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *normals
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least 3 times maxSize floats to contain the collision contact normals.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *penetration
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to and array of a least maxSize floats to contain the collision penetration at each contact.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> the number of contact points.
  
<p>   <h4>Remarks</h4> by passing zero as <b>maxSize</b> not contact will be calculated and the function will just determine the time of impact is any.
  
<p>   <h4>Remarks</h4> if the body are interpenetrating the time of impact will be zero.
  
<p>   <h4>Remarks</h4> if the bodies do not collide time of impact will be set to <b>timestep</b>
  
<p>   <h4>Remarks</h4> This function can be used as a low-level building block for a stand-alone collision system. 
   Applications that have already there own physics system, and only want and quick and fast collision solution, 
   can use Newton advanced collision engine as the low level collision detection part. 
   To do this the application only needs to initialize Newton, create the collision primitives at application discretion, 
   and just call this function when the objects are in close proximity. Applications using Newton as a collision system 
   only, are responsible for implementing their own broad phase collision determination, based on any high level tree structure. 
   Also the application should implement their own trivial aabb test, before calling this function .
  
<p>   <h4>See also</h4> <a HREF="#NewtonCollisionCollide">NewtonCollisionCollide</a>, <a HREF="#NewtonCollisionClosestPoint">NewtonCollisionClosestPoint</a>, <a HREF="#NewtonCollisionPointDistance">NewtonCollisionPointDistance</a>, <a HREF="#NewtonCollisionRayCast">NewtonCollisionRayCast</a>, <a HREF="#NewtonCollisionCalculateAABB">NewtonCollisionCalculateAABB</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCollisionRayCast"></a>
<a NAME="NewtonCollisionRayCast"></a>
NewtonCollisionRayCast
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonCollisionRayCast</font>(<br> const NewtonCollision* collisionPtr,<br> const dFloat* p0,<br> const dFloat* p1,<br> dFloat* normal,<br> int* attribute)
</div>
<div class=SectionText>
Ray cast specific collision object.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the collision object.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *p0
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats representing the ray origin in the local space of the geometry.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *p1
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats representing the ray end in the local space of the geometry.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *normal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the normal at the intersection point.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> *attribute
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least one floats to hold the ID of the face hit by the ray.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the parametric value of the intersection, between 0.0 and 1.0, an value larger than 1.0 if the ray miss.
  
<p>   <h4>Remarks</h4> This function is intended for applications using newton collision system separate from the dynamics system, also for applications  
   implementing any king of special purpose logic like sensing distance to another object.
  
<p>   <h4>Remarks</h4> the ray most be local to the collisions geometry, for example and application ray casting the collision geometry of 
   of a rigid body, must first take the points p0, and p1 to the local space of the rigid body by multiplying the points by the 
   inverse of he rigid body transformation matrix. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonCollisionClosestPoint">NewtonCollisionClosestPoint</a>, <a HREF="#NewtonCollisionPointDistance">NewtonCollisionPointDistance</a>, <a HREF="#NewtonCollisionCollide">NewtonCollisionCollide</a>, <a HREF="#NewtonCollisionCalculateAABB">NewtonCollisionCalculateAABB</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCollisionCalculateAABB"></a>
<a NAME="NewtonCollisionCalculateAABB"></a>
NewtonCollisionCalculateAABB
</h3>
<div class=Api>
void <font class=ApiName>NewtonCollisionCalculateAABB</font>(<br> const NewtonCollision* collisionPtr,<br> const dFloat <b>offsetMatrix,<br> dFloat</b> p0,<br> dFloat* p1)
</div>
<div class=SectionText>
Calculate an axis-aligned bounding box for this collision, the box is calculated relative to <b>offsetMatrix</b>. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the collision object.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *offsetMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset matrix used as the coordinate system and center of the AABB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *p0
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold minimum value for the AABB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *p1
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold maximum value for the AABB.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>See also</h4> <a HREF="#NewtonCollisionClosestPoint">NewtonCollisionClosestPoint</a>, <a HREF="#NewtonCollisionPointDistance">NewtonCollisionPointDistance</a>, <a HREF="#NewtonCollisionCollide">NewtonCollisionCollide</a>, <a HREF="#NewtonCollisionRayCast">NewtonCollisionRayCast</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCollisionMakeUnique"></a>
<a NAME="NewtonCollisionMakeUnique"></a>
NewtonCollisionMakeUnique
</h3>
<div class=Api>
void <font class=ApiName>NewtonCollisionMakeUnique</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonCollision* collisionPtr)
</div>
<div class=SectionText>
Convert a collision primitive to a unique instance by removing it for the collision cache.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the collision object
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> 
   This function will not make preexisting collision object unique instances, so for best result this function should be call immediately after the 
   creation of the collision object.
  
<p>   <h4>Remarks</h4> 
   Collision objects are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonReleaseCollision"></a>
<a NAME="NewtonReleaseCollision"></a>
NewtonReleaseCollision
</h3>
<div class=Api>
void <font class=ApiName>NewtonReleaseCollision</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonCollision* collisionPtr)
</div>
<div class=SectionText>
Release a reference from this collision object returning control to Newton.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the collision object
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> 
   Collision objects are reference counted objects. The application should call <b>NewtonReleaseCollision</b> in order to release references to the object.
   Neglecting to release references to collision primitives is a common cause of memory leaks.


</div>
</div>
<div class=Section>
<h3>
<a NAME="Transform^utility^functions"></a>
<a NAME="Transform utility functions"></a>
Transform utility functions
</h3>
<div class=SectionText>

                                                                                                 
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonGetEulerAngle"></a>
<a NAME="NewtonGetEulerAngle"></a>
NewtonGetEulerAngle
</h3>
<div class=Api>
void <font class=ApiName>NewtonGetEulerAngle</font>(<br> const dFloat* matrix,<br> dFloat* angles)
</div>
<div class=SectionText>
Get the three Euler angles from a 4x4 rotation matrix arranged in row-major order.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const dFloat</b> matrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the 4x4 rotation matrix.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> angles
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the Euler angles.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The motivation for this function is that many graphics engines still use Euler angles to represent the orientation
   of graphics entities. 
   The angles are expressed in radians and represent: 
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>angle[0]</b>
</td>
<td class=DefSep>-</td>
<td class=DefText>
rotation about first matrix row
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>angle[1]</b>
</td>
<td class=DefSep>-</td>
<td class=DefText>
rotation about second matrix row
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>angle[2]</b>
</td>
<td class=DefSep>-</td>
<td class=DefText>
rotation about third matrix row
</td>
</tr>
</table>

<p>   	
   <h4>See also</h4> <a HREF="#NewtonSetEulerAngle">NewtonSetEulerAngle</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSetEulerAngle"></a>
<a NAME="NewtonSetEulerAngle"></a>
NewtonSetEulerAngle
</h3>
<div class=Api>
void <font class=ApiName>NewtonSetEulerAngle</font>(<br> const dFloat* angles,<br> dFloat* matrix)
</div>
<div class=SectionText>
Build a rotation matrix from the Euler angles in radians.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>dFloat</b> matrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the 4x4 rotation matrix.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> angles
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the Euler angles.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The motivation for this function is that many graphics engines still use Euler angles to represent the orientation
   of graphics entities. 
   The angles are expressed in radians and represent: 
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>angle[0]</b>
</td>
<td class=DefSep>-</td>
<td class=DefText>
rotation about first matrix row
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>angle[1]</b>
</td>
<td class=DefSep>-</td>
<td class=DefText>
rotation about second matrix row
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>angle[2]</b>
</td>
<td class=DefSep>-</td>
<td class=DefText>
rotation about third matrix row
</td>
</tr>
</table>

<p>   	
   <h4>See also</h4> <a HREF="#NewtonGetEulerAngle">NewtonGetEulerAngle</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Rigid^body^interface"></a>
<a NAME="Rigid body interface"></a>
Rigid body interface
</h3>
<div class=SectionText>

                                                                                                 
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateBody"></a>
<a NAME="NewtonCreateBody"></a>
NewtonCreateBody
</h3>
<div class=Api>
NewtonBody* <font class=ApiName>NewtonCreateBody</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonCollision* collisionPtr)
</div>
<div class=SectionText>
Create a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *collisionPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the collision object.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the rigid body.
  
<p>   <h4>Remarks</h4> This function creates a Newton rigid body and assigns a <b>collisionPtr</b> as the collision geometry representing the rigid body.
   This function increments the reference count of the collision geometry. 
   All event functions are set to NULL and the material gruopID of the body is set to the default GroupID.
  
<p>   <h4>See also</h4> <a HREF="#NewtonDestroyBody">NewtonDestroyBody</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonDestroyBody"></a>
<a NAME="NewtonDestroyBody"></a>
NewtonDestroyBody
</h3>
<div class=Api>
void <font class=ApiName>NewtonDestroyBody</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonBody* bodyPtr)
</div>
<div class=SectionText>
Destroy a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body to be destroyed.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> If this function is called from inside a simulation step the destruction of the body will be delayed until end of the time step.
   This function will decrease the reference count of the collision geometry by one. If the reference count reaches zero, then the collision 
   geometry will be destroyed. This function will destroy all joints associated with this body.
  
<p>   <h4>See also</h4> <a HREF="#NewtonCreateBody">NewtonCreateBody</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetUserData"></a>
<a NAME="NewtonBodySetUserData"></a>
NewtonBodySetUserData
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodySetUserData</font>(<br> const NewtonBody* bodyPtr,<br> void* userDataPtr)
</div>
<div class=SectionText>
Store a user defined data value with the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userDataPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the user defined user data value.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The application can store a user defined value with the Body. This value can be the pointer to a structure containing some application data for special effect. 
   if the application allocate some resource to store the user data, the application can register a joint destructor to get rid of the allocated resource when the body is destroyed
   
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetUserData">NewtonBodyGetUserData</a>, <a HREF="#NewtonBodySetDestructorCallback">NewtonBodySetDestructorCallback</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetUserData"></a>
<a NAME="NewtonBodyGetUserData"></a>
NewtonBodyGetUserData
</h3>
<div class=Api>
void* <font class=ApiName>NewtonBodyGetUserData</font>(const NewtonBody* bodyPtr)
</div>
<div class=SectionText>
Retrieve a user defined data value stored with the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> The user defined data.
  
<p>   <h4>Remarks</h4> The application can store a user defined value with a rigid body. This value can be the pointer
   to a structure which is the graphical representation of the rigid body.
   
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetUserData">NewtonBodySetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetWorld"></a>
<a NAME="NewtonBodyGetWorld"></a>
NewtonBodyGetWorld
</h3>
<div class=Api>
NewtonWorld* <font class=ApiName>NewtonBodyGetWorld</font>(const NewtonBody* bodyPtr)
</div>
<div class=SectionText>
Retrieve get the pointer to the world from the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the world that own this body.
  
<p>   <h4>Remarks</h4> The application can use this function to determine what world own this body. If the application 
   have to get the world from a joint, it can do so by getting one of the bodies attached to the joint and getting the world from 
   that body.
   
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetTransformCallback"></a>
<a NAME="NewtonBodySetTransformCallback"></a>
NewtonBodySetTransformCallback
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodySetTransformCallback</font>(<br> const NewtonBody* bodyPtr,<br> NewtonSetTransform callback)
</div>
<div class=SectionText>
Assign a transformation event function to the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>    
<tr class=Def>
<td class=Def>
NewtonSetTransform callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a function callback in used to update the transformation matrix of the visual object that represents the rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The function <b>NewtonSetTransform callback</b> is called by the Newton engine every time a visual object that represents the rigid body has changed.
   The application can obtain the pointer user data value that points to the visual object. 
   The Newton engine does not call the <b>NewtonSetTransform callback</b> function for bodies that are inactive or have reached a state of stable equilibrium.
  
<p>   <h4>Remarks</h4> The matrix should be organized in row-major order (this is the way directX stores matrices).
   If you are using OpenGL matrices (column-major) you will need to transpose the matrices into a local array, before
   you pass them to Newton.
   
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetUserData">NewtonBodyGetUserData</a>, <a HREF="#NewtonBodyGetUserData">NewtonBodyGetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetAutoactiveCallback"></a>
<a NAME="NewtonBodySetAutoactiveCallback"></a>
NewtonBodySetAutoactiveCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetAutoactiveCallback</font>(<br> const NewtonBody* bodyPtr,<br> NewtonBodyActivationState callback)
</div>
<div class=SectionText>
Assign an activation/deativation callback function.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>    
<tr class=Def>
<td class=Def>
NewtonBodyActivationStatem callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a function callback is used to be called when the body is about to be activated or deactivated.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> this function sets an activation and deactivation callback with the body. The application can use this method to implement advanced scene management control.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetForceAndTorqueCallback"></a>
<a NAME="NewtonBodySetForceAndTorqueCallback"></a>
NewtonBodySetForceAndTorqueCallback
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodySetForceAndTorqueCallback</font>(<br> const NewtonBody* bodyPtr,<br> NewtonApplyForceAndTorque callback)
</div>
<div class=SectionText>
Assign an event function for applying external force and torque to a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>    
<tr class=Def>
<td class=Def>
NewtonApplyForceAndTorque callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a function callback used to apply force and torque to a rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> Before the <b>NewtonApplyForceAndTorque callback</b> is called for a body, Newton first clears the net force and net torque for the body. 
  
<p>   <h4>Remarks</h4> The function <b>NewtonApplyForceAndTorque callback</b> is called by the Newton Engine every time an active body is going to be simulated. 
   The Newton Engine does not call the <b>NewtonApplyForceAndTorque callback</b> function for bodies that are inactive or have reached a state of stable equilibrium.
   
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetUserData">NewtonBodyGetUserData</a>, NewtonBodyGetUserData, <a HREF="#NewtonBodyGetForceAndTorqueCallback">NewtonBodyGetForceAndTorqueCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetForceAndTorqueCallback"></a>
<a NAME="NewtonBodyGetForceAndTorqueCallback"></a>
NewtonBodyGetForceAndTorqueCallback
</h3>
<div class=Api>
NewtonApplyForceAndTorque <font class=ApiName>NewtonBodyGetForceAndTorqueCallback</font>(const NewtonBody* bodyPtr)
</div>
<div class=SectionText>
Return the pointer to the current force and torque call back function.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> pointer to the force call back.
  
<p>   <h4>Remarks</h4> This function can be used to concatenate different force calculation components making more modular the 
   design of function components dedicated to apply special effect. For example a body may have a basic force a force that
   only apply the effect of gravity, but that application can place a region in where there can be a fluid volume, or another gravity field.
   we this function the application can read the correct function and save into a local variable, and set a new one.
   this new function will firs call the save function pointer and upon return apply the correct effect.
   this similar to the concept of virtual methods on objected oriented languages.
  
<p>   <h4>Remarks</h4> The function <b>NewtonApplyForceAndTorque callback</b> is called by the Newton Engine every time an active body is going to be simulated. 
   The Newton Engine does not call the <b>NewtonApplyForceAndTorque callback</b> function for bodies that are inactive or have reached a state of stable equilibrium.
   
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetUserData">NewtonBodyGetUserData</a>, NewtonBodyGetUserData, <a HREF="#NewtonBodySetForceAndTorqueCallback">NewtonBodySetForceAndTorqueCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetDestructorCallback"></a>
<a NAME="NewtonBodySetDestructorCallback"></a>
NewtonBodySetDestructorCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetDestructorCallback</font>(<br> const NewtonBody* bodyPtr,<br> NewtonBodyDestructor callback)
</div>
<div class=SectionText>
Assign an event function to be called when this body is about to be destroyed.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body to be destroyed.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonBodyDestructor</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a function callback.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> 
   This function <b>NewtonBodyDestructor callback</b> acts like a destruction function in CPP. This function
   is called when the body and all data joints associated with the body are about to be destroyed.
   The application could use this function to destroy or release any resource associated with this body. 
   The application should not make reference to this body after this function returns.
  
<p>   <h4>Remarks</h4> 
   The destruction of a body will destroy all joints associated with the body.
   
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetUserData">NewtonBodyGetUserData</a>, <a HREF="#NewtonBodyGetUserData">NewtonBodyGetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetMassMatrix"></a>
<a NAME="NewtonBodySetMassMatrix"></a>
NewtonBodySetMassMatrix
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetMassMatrix</font>(<br> const NewtonBody* bodyPtr,<br> dFloat mass,<br> dFloat Ixx,<br> dFloat Iyy,<br> dFloat Izz)
</div>
<div class=SectionText>
Set the mass matrix of a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> mass
</td>
<td class=DefSep>-</td>
<td class=DefText>
mass value.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> Ixx
</td>
<td class=DefSep>-</td>
<td class=DefText>
moment of inertia of the first principal axis of inertia of the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> Iyy
</td>
<td class=DefSep>-</td>
<td class=DefText>
moment of inertia of the first principal axis of inertia of the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> Izz
</td>
<td class=DefSep>-</td>
<td class=DefText>
moment of inertia of the first principal axis of inertia of the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> Newton algorithms have no restriction on the values for the mass, but due to floating point dynamic
   range (24 bit precision) it is best if the ratio between the heaviest and the lightest body in the scene is limited to 200.
   There are no special utility functions in Newton to calculate the moment of inertia of common primitives. 
   The application should specify the inertial values, keeping in mind that realistic inertia values are necessary for
   realistic physics behavior.
  
<p>   <h4>See also</h4> <a HREF="#NewtonConvexCollisionCalculateInertialMatrix">NewtonConvexCollisionCalculateInertialMatrix</a>, <a HREF="#NewtonBodyGetMassMatrix">NewtonBodyGetMassMatrix</a>, <a HREF="#NewtonBodyGetInvMass">NewtonBodyGetInvMass</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetMassMatrix"></a>
<a NAME="NewtonBodyGetMassMatrix"></a>
NewtonBodyGetMassMatrix
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodyGetMassMatrix</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* mass,<br> dFloat* Ixx,<br> dFloat* Iyy,<br> dFloat* Izz)
</div>
<div class=SectionText>
Get the mass matrix of a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *mass
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a variable that will hold the mass value of the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *Ixx
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a variable that will hold the moment of inertia of the first principal axis of inertia of the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *Iyy
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a variable that will hold the moment of inertia of the first principal axis of inertia of the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *Izz
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a variable that will hold the moment of inertia of the first principal axis of inertia of the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetMassMatrix">NewtonBodySetMassMatrix</a>, <a HREF="#NewtonBodyGetInvMass">NewtonBodyGetInvMass</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetInvMass"></a>
<a NAME="NewtonBodyGetInvMass"></a>
NewtonBodyGetInvMass
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyGetInvMass</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* invMass,<br> dFloat* invIxx,<br> dFloat* invIyy,<br> dFloat* invIzz)
</div>
<div class=SectionText>
Get the inverse mass matrix of a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *invMass
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a variable that will hold the mass inverse value of the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *invIxx
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a variable that will hold the moment of inertia inverse of the first principal axis of inertia of the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *invIyy
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a variable that will hold the moment of inertia inverse of the first principal axis of inertia of the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *invIzz
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a variable that will hold the moment of inertia inverse of the first principal axis of inertia of the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetMassMatrix">NewtonBodySetMassMatrix</a>, <a HREF="#NewtonBodyGetMassMatrix">NewtonBodyGetMassMatrix</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetMatrix"></a>
<a NAME="NewtonBodySetMatrix"></a>
NewtonBodySetMatrix
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetMatrix</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* matrixPtr)
</div>
<div class=SectionText>
Set the transformation matrix of a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the global matrix of the rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The matrix should be arranged in row-major order (this is the way directX stores matrices).
   If you are using OpenGL matrices (column-major) you will need to transpose you matrices into a local array, before
   passing them to Newton.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetMatrix">NewtonBodyGetMatrix</a>, <a HREF="#NewtonBodySetMatrixRecursive">NewtonBodySetMatrixRecursive</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetMatrixRecursive"></a>
<a NAME="NewtonBodySetMatrixRecursive"></a>
NewtonBodySetMatrixRecursive
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetMatrixRecursive</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* matrixPtr)
</div>
<div class=SectionText>
Apply hierarchical transformation to a body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the global matrix of the rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function applies the transformation matrix to the <b>body</b> and also applies the appropriate transformation matrix to
   set of articulated bodies. If the body is in contact with another body the other body is not transformed.
  
<p>   <h4>Remarks</h4> this funtion should not be used to transform set of articulated bodies that are connected to a static body.
   doing so will result in umprediactable results. Think for example moving a chain attached to a ceiling from one place to another,
   to do that in real life a person first need to desconect the chain (destroy the joint), move the chain (apply teh tranfomation to the 
   entire chain), the reconect it in the new position (recreate the joint again).
  
<p>   <h4>Remarks</h4> this function will set to zero the linear and angular velocity of all bodies that are part of the set of articulated body array.
  
<p>   <h4>Remarks</h4> The matrix should be arranged in row-major order (this is the way directX stores matrices).
   If you are using OpenGL matrices (column-major) you will need to transpose you matrices into a local array, before
   passing them to Newton.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetMatrix">NewtonBodySetMatrix</a>  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetMatrix"></a>
<a NAME="NewtonBodyGetMatrix"></a>
NewtonBodyGetMatrix
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyGetMatrix</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* matrixPtr)
</div>
<div class=SectionText>
Get the transformation matrix of a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrixPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats that will hold the global matrix of the rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The matrix should be arranged in row-major order (this is the way directX stores matrices).
   If you are using OpenGL matrices (column-major) you will need to transpose you matrices into a local array, before
   passing them to Newton.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetMatrix">NewtonBodySetMatrix</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetForce"></a>
<a NAME="NewtonBodySetForce"></a>
NewtonBodySetForce
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodySetForce</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* forcePtr)
</div>
<div class=SectionText>
Set the net force applied to a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *forcePtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats containing the net force to be applied to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function is only effective when called from <b>NewtonApplyForceAndTorque callback</b>
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyAddForce">NewtonBodyAddForce</a>, <a HREF="#NewtonBodyGetForce">NewtonBodyGetForce</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyAddForce"></a>
<a NAME="NewtonBodyAddForce"></a>
NewtonBodyAddForce
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodyAddForce</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* forcePtr)
</div>
<div class=SectionText>
Add the net force applied to a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body to be destroyed.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *forcePtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats containing the net force to be applied to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function is only effective when called from <b>NewtonApplyForceAndTorque callback</b>
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetForce">NewtonBodySetForce</a>, <a HREF="#NewtonBodyGetForce">NewtonBodyGetForce</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetForce"></a>
<a NAME="NewtonBodyGetForce"></a>
NewtonBodyGetForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyGetForce</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* vectorPtr)
</div>
<div class=SectionText>
Get the net force applied to a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *forcePtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats to hold the net force of the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function is only effective when called from <b>NewtonApplyForceAndTorque callback</b>
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyAddForce">NewtonBodyAddForce</a>, NewtonBodyGetForce


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetTorque"></a>
<a NAME="NewtonBodySetTorque"></a>
NewtonBodySetTorque
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodySetTorque</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* forcePtr)
</div>
<div class=SectionText>
Set the net torque applied to a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *torquePtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats containing the net torque to be applied to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function is only effective when called from <b>NewtonApplyForceAndTorque callback</b>
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyAddTorque">NewtonBodyAddTorque</a>, <a HREF="#NewtonBodyGetTorque">NewtonBodyGetTorque</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetCentreOfMass"></a>
<a NAME="NewtonBodySetCentreOfMass"></a>
NewtonBodySetCentreOfMass
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetCentreOfMass</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* comPtr)
</div>
<div class=SectionText>
Set the relative position of the center of mass of a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *comPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats containing the relative offset of the centre of mass of the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This funtion can be used to set the relative offset of the centre of mass of a rigid body.
   when a rigid body is created the centre of mass is set the the point c(0, 0, 0), and normally this is 
   the best setting for a rigid body. However the are situations in which and object does not have simetry or
   simple some kind of special effect is desired, and this origin need to be changed.
  
<p>   <h4>Remarks</h4> Care must be taken when ofsseting the centre of mass of a body. 
   The applycation must make sure that the external torques resulting from forces applied at at point
   relative to the center of mass are calculared apropriatly.
   this could be done Transform and Torque callback funtion as teh follow psudo code fragment shows:
  
<p>   Matrix matrix;
   Vector centre;
  
<p>   NewtonGatMetrix(body, matrix)
   NewtonGetCentreOfMass(body, centre);
  
<p>   for global space torque.  
   Vector localForce (fx, fy, fz);
   Vector localPosition (x, y, z);
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
Vector localTroque (crossproduct ((localPosition
</td>
<td class=DefSep>-</td>
<td class=DefText>
centre). localForce);
   Vector globalTroque (matrix.RotateVector (localTroque));
</td>
</tr>
</table>

<p>   
   for global space torque. 
   Vector globalCentre (matrix.TranformVector (centre));
   Vector globalPosition (x, y, z);
   Vector globalForce (fx, fy, fz);
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
Vector globalTroque (crossproduct ((globalPosition
</td>
<td class=DefSep>-</td>
<td class=DefText>
globalCentre). globalForce);
</td>
</tr>
</table>

<p>  
   <h4>See also</h4> <a HREF="#NewtonConvexCollisionCalculateInertialMatrix">NewtonConvexCollisionCalculateInertialMatrix</a>, <a HREF="#NewtonBodyGetCentreOfMass">NewtonBodyGetCentreOfMass</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyAddTorque"></a>
<a NAME="NewtonBodyAddTorque"></a>
NewtonBodyAddTorque
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodyAddTorque</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* forcePtr)
</div>
<div class=SectionText>
Add the net torque applied to a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *torquePtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats containing the net torque to be applied to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function is only effective when called from <b>NewtonApplyForceAndTorque callback</b>
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetTorque">NewtonBodySetTorque</a>, <a HREF="#NewtonBodyGetTorque">NewtonBodyGetTorque</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetTorque"></a>
<a NAME="NewtonBodyGetTorque"></a>
NewtonBodyGetTorque
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodyGetTorque</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* vectorPtr)
</div>
<div class=SectionText>
Get the net torque applied to a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *torquePtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats to hold the net torque of the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function is only effective when called from <b>NewtonApplyForceAndTorque callback</b>
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyAddTorque">NewtonBodyAddTorque</a>, NewtonBodyGetTorque


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetCentreOfMass"></a>
<a NAME="NewtonBodyGetCentreOfMass"></a>
NewtonBodyGetCentreOfMass
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyGetCentreOfMass</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* comPtr)
</div>
<div class=SectionText>
Get the relative position of the center of mass of a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *comPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats to hold the relative offset of the centre of mass of the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function can be used to set the relative offset of the center of mass of a rigid body.
   when a rigid body is crated the center of mass is set the the point c(0, 0, 0), and normally this is 
   the best setting for a rigid body. However the are situations in which and object does not have simetry or
   simple some kind of special effect is desired, and this origin need to be changed.
  
<p>   <h4>Remarks</h4> This function can be used in conjunction with <b>NewtonConvexCollisionCalculateInertialMatrix</b> 
  
<p>   <h4>See also</h4> <a HREF="#NewtonConvexCollisionCalculateInertialMatrix">NewtonConvexCollisionCalculateInertialMatrix</a>, <a HREF="#NewtonBodySetCentreOfMass">NewtonBodySetCentreOfMass</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyAddBuoyancyForce"></a>
<a NAME="NewtonBodyAddBuoyancyForce"></a>
NewtonBodyAddBuoyancyForce
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodyAddBuoyancyForce</font>(<br> 
	const NewtonBody* bodyPtr,<br> 
	dFloat fluidDensity,<br> 
	dFloat fluidLinearViscosity,<br> 
	dFloat fluidAngularViscosity,<br> 
	const dFloat* gravityVector,<br> 
	NewtonGetBuoyancyPlane buoyancyPlane,<br>
	void *context)
</div>
<div class=SectionText>
Add buoyancy force and torque for bodies immersed in a fluid.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> fluidDensity
</td>
<td class=DefSep>-</td>
<td class=DefText>
fluid density.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> fluidLinearViscosity
</td>
<td class=DefSep>-</td>
<td class=DefText>
fluid linear viscosity (resistance to linear tranlation).
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> fluidAngularViscosity
</td>
<td class=DefSep>-</td>
<td class=DefText>
fluid angular viscosity (resistance to rotation).
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *gravityVector
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of floats containing the gravity vector.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonGetBuoyancyPlane</b> *buoyancyPlane
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least 4 floats containing the plane equation of the surface of the fluid. This parameter can be NULL
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function is only effective when called from <b>NewtonApplyForceAndTorque callback</b>
  
<p>   <h4>Remarks</h4> This function adds buoyancy force and torque to a body when it is immersed in a fluid.
   The force is calculated according to Archimedes Buoyancy Principle. When the parameter <b>buoyancyPlane</b> is set to NULL, the body is considered
   to completely immersed in the fluid. This can be used to simulate boats and lighter than air vehicles etc..
  
<p>   <h4>Remarks</h4> If <b>buoyancyPlane</b> return 0 buoyancy calculation for this collision primitive is inghnored, this coudl be used to filter bouyancy calculation 
   of compound collision geometry with diffrents IDs. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonConvexCollisionCalculateVolume">NewtonConvexCollisionCalculateVolume</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetCollision"></a>
<a NAME="NewtonBodySetCollision"></a>
NewtonBodySetCollision
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetCollision</font>(<br> const NewtonBody* bodyPtr,<br> const NewtonCollision* collisionPtr)
</div>
<div class=SectionText>
Assign a collision primitive to the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const collisionPtr</b> *collisionPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the new collision geometry.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> This function replaces a collision geometry of a body with the new collision geometry.
   This function increments the reference count of the collision geometry and decrements the reference count
   of the old collision geometry. If the reference count of the old collision geometry reaches zero, the old collision geometry is destroyed.
   This function can be used to swap the collision geometry of bodies at runtime.
  
<p>   <h4>See also</h4> <a HREF="#NewtonCreateBody">NewtonCreateBody</a>, <a HREF="#NewtonBodyGetCollision">NewtonBodyGetCollision</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyCoriolisForcesMode"></a>
<a NAME="NewtonBodyCoriolisForcesMode"></a>
NewtonBodyCoriolisForcesMode
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodyCoriolisForcesMode</font>(<br> const NewtonBody* bodyPtr,<br> int mode)
</div>
<div class=SectionText>
Enable or disable Coriolis and gyroscopic force calculation for this body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> mode
</td>
<td class=DefSep>-</td>
<td class=DefText>
force mode zero indicate not gyroscopic force calculation.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> Gyroscopic forces internal forces generated as a result of an asymmetric tensor. They are a pure mathematical consequence that the physics have to comply in order to agree with the math. As Gyroscopic forces are not real forces but the result of net unbalance of the changing inertia tensor or a rigid body when its angular velocity is measured on a reference frame different than the bodys own.  
   Gyroscopic forces are extremely non linear by nature, therefore a first order implicit integrator will have a extremely hard time at dealing with this kind of forces, however because the fact that they are not real forces they do not make much difference in the outcome of the integration.
   Fortunately due to the fact that the magnitude of gyroscopic forces is proportional to the unbalance of the inertia tensor, it is possible to disregard the effect of this forces by assuming their inertial tensor is symmetric for the purpose of this calculation. For most cases an ordinary person is not capable to distinguish the motion of a body subject to gyroscopic forces and one that is not, especially when the motion is constrained.
   Because of this fact gyroscopic force are turned off by default in Newton, however there are cases when the desire effect is precisely to simulate these forces like a spinning top, or the design of a space navigational system, etc. The most important feature of gyroscopic forces is that they make the rigid body to process. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetCollision"></a>
<a NAME="NewtonBodyGetCollision"></a>
NewtonBodyGetCollision
</h3>
<div class=Api>
NewtonCollision* <font class=ApiName>NewtonBodyGetCollision</font>(const NewtonBody* bodyPtr)
</div>
<div class=SectionText>
Get the collision primitive of a body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to body collision geometry.
  
<p>   <h4>Remarks</h4> This function does not increment the reference count of the collision geometry. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonCreateBody">NewtonCreateBody</a>, <a HREF="#NewtonBodySetCollision">NewtonBodySetCollision</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetMaterialGroupID"></a>
<a NAME="NewtonBodySetMaterialGroupID"></a>
NewtonBodySetMaterialGroupID
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetMaterialGroupID</font>(<br> const NewtonBody* bodyPtr,<br> int id)
</div>
<div class=SectionText>
Assign a material group id to the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id
</td>
<td class=DefSep>-</td>
<td class=DefText>
id of a previously created material group.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> When the application creates a body, the default material group, <b>defaultGroupId</b>, is applied by default.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetMaterialGroupID">NewtonBodyGetMaterialGroupID</a>, <a HREF="#NewtonMaterialCreateGroupID">NewtonMaterialCreateGroupID</a>, <a HREF="#NewtonMaterialGetDefaultGroupID">NewtonMaterialGetDefaultGroupID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetMaterialGroupID"></a>
<a NAME="NewtonBodyGetMaterialGroupID"></a>
NewtonBodyGetMaterialGroupID
</h3>
<div class=Api>
int <font class=ApiName>NewtonBodyGetMaterialGroupID</font>(const NewtonBody* bodyPtr)
</div>
<div class=SectionText>
Get the material group id of the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id
</td>
<td class=DefSep>-</td>
<td class=DefText>
id of a previously created material group.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetMaterialGroupID">NewtonBodySetMaterialGroupID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetContinuousCollisionMode"></a>
<a NAME="NewtonBodySetContinuousCollisionMode"></a>
NewtonBodySetContinuousCollisionMode
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetContinuousCollisionMode</font>(<br> const NewtonBody* bodyPtr,<br> unsigned state)
</div>
<div class=SectionText>
Set the continuous collision state mode for this rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> state
</td>
<td class=DefSep>-</td>
<td class=DefText>
collision state. 1 indicates this body may tunnel through other objects while moving at high speed. 0 ignore high speed collision checks.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> continue collision mode enable allow the engine to predict colliding contact on rigid bodies
   Moving at high speed of subject to strong forces.
  
<p>   <h4>Remarks</h4> continue collision mode does not prevent rigid bodies from interpenetration instead it prevent bodies from 
   passing trough each others by extrapolating contact points when the bodies normal contact calculation determine the bodies are not colliding. 
  
<p>   <h4>Remarks</h4> for performance reason the bodies angular velocities is only use on the broad face of the collision, 
   but not on the contact calculation. 
   
<p>   <h4>Remarks</h4> continue collision does not perform back tracking to determine time of contact, instead it extrapolate contact by incrementally 
   extruding the collision geometries of the two colliding bodies along the linear velocity of the bodies during the time step, 
   if during the extrusion colliding contact are found, a collision is declared and the normal contact resolution is called. 
  
<p>   <h4>Remarks</h4> for continue collision to be active the continue collision mode must on the material pair of the colliding bodies as well as on at least one of the two colliding bodies.
  
<p>   <h4>Remarks</h4> Because there is penalty of about 40% to 80% depending of the shape complexity of the collision geometry, this feature is set 
   off by default. It is the job of the application to determine what bodies need this feature on. Good guidelines are: very small objects, 
   and bodies that move a height speed.  
   
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetContinuousCollisionMode">NewtonBodyGetContinuousCollisionMode</a>, NewtonBodySetContinuousCollisionMode


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetContinuousCollisionMode"></a>
<a NAME="NewtonBodyGetContinuousCollisionMode"></a>
NewtonBodyGetContinuousCollisionMode
</h3>
<div class=SectionText>
Get the continuous collision state mode for this rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> 
  Remark: Because there is there is penalty of about 3 to 5 depending of the shape complexity of the collision geometry, this feature is set 
  off by default. It is the job of the application to determine what bodies need this feature on. Good guidelines are: very small objects, 
  and bodies that move a height speed.  
  
<p>  <h4>Remark</h4> this feature is currently disabled:
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetContinuousCollisionMode">NewtonBodySetContinuousCollisionMode</a>, <a HREF="#NewtonBodySetContinuousCollisionMode">NewtonBodySetContinuousCollisionMode</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetJointRecursiveCollision"></a>
<a NAME="NewtonBodySetJointRecursiveCollision"></a>
NewtonBodySetJointRecursiveCollision
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetJointRecursiveCollision</font>(<br> const NewtonBody* bodyPtr,<br> unsigned state)
</div>
<div class=SectionText>
Set the collision state flag of this body when the body is connected to another body by a hierarchy of joints.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> state
</td>
<td class=DefSep>-</td>
<td class=DefText>
collision state. 1 indicates this body will collide with any linked body. 0 disable collision with body connected to this one by joints.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> sometimes when making complicated arrangements of linked bodies it is possible the collision geometry of these bodies is in the way of the 
   joints work space. This could be a problem for the normal operation of the joints. When this situation happens the application can determine which bodies
   are the problem and disable collision for those bodies while they are linked by joints. For the collision to be disable for a pair of body, 
   both bodies must have the collision disabled. If the joints connecting the bodies are destroyed these bodies become collidable automatically.
   This feature can also be achieved by making special material for the whole configuration of jointed bodies, however it is a lot easier just to set collision disable
   for jointed bodies.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetMaterialGroupID">NewtonBodySetMaterialGroupID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetJointRecursiveCollision"></a>
<a NAME="NewtonBodyGetJointRecursiveCollision"></a>
NewtonBodyGetJointRecursiveCollision
</h3>
<div class=SectionText>
Get the collision state flag when the body is joint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> return the collision state flag for this body.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetMaterialGroupID">NewtonBodySetMaterialGroupID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetAutoFreeze"></a>
<a NAME="NewtonBodySetAutoFreeze"></a>
NewtonBodySetAutoFreeze
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetAutoFreeze</font>(<br> const NewtonBody* bodyPtr,<br> int state)
</div>
<div class=SectionText>
Set the auto-activation mode for this body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> state
</td>
<td class=DefSep>-</td>
<td class=DefText>
active mode: 1 = auto-activation on (controlled by Newton). 0 = auto-activation off (controlled by the application).
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> Bodies are created with auto-activation on by default. 
  
<p>   <h4>Remarks</h4> Autoactivation enabled is the default state for the majority of bodies in a large scene.
   However, for player control, ai control or some other special circumstance, the application may want to control
   the activation/deactivation of the body. In that case, the application may call NewtonBodySetAutoFreeze (body, 0) followed by
   NewtonWorldUnfreezeBody(world, body), this will make the body active forever. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonWorldFreezeBody">NewtonWorldFreezeBody</a>, <a HREF="#NewtonWorldUnfreezeBody">NewtonWorldUnfreezeBody</a>, <a HREF="#NewtonBodyGetAutoFreeze">NewtonBodyGetAutoFreeze</a>, <a HREF="#NewtonBodySetFreezeTreshold">NewtonBodySetFreezeTreshold</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetAutoFreeze"></a>
<a NAME="NewtonBodyGetAutoFreeze"></a>
NewtonBodyGetAutoFreeze
</h3>
<div class=Api>
int <font class=ApiName>NewtonBodyGetAutoFreeze</font>(const NewtonBody* bodyPtr)
</div>
<div class=SectionText>
Get the auto-activation state of the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Freeze state: 1 = frozen. 0 = active.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetAutoFreeze">NewtonBodySetAutoFreeze</a>, <a HREF="#NewtonBodyGetSleepingState">NewtonBodyGetSleepingState</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetSleepingState"></a>
<a NAME="NewtonBodyGetSleepingState"></a>
NewtonBodyGetSleepingState
</h3>
<div class=Api>
int <font class=ApiName>NewtonBodyGetSleepingState</font>(const NewtonBody* bodyPtr)
</div>
<div class=SectionText>
Return the sleep mode of a rigid body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>
</table>

<p>   
   <h4>Return</h4> Autoactivation state: 1 = auto-activation on. 0 = auto-activation off.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetAutoFreeze">NewtonBodySetAutoFreeze</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetFreezeTreshold"></a>
<a NAME="NewtonBodySetFreezeTreshold"></a>
NewtonBodySetFreezeTreshold
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetFreezeTreshold</font>(<br> const NewtonBody* bodyPtr,<br> dFloat freezeSpeedMag2,<br> dFloat freezeOmegaMag2,<br> int framesCount)
</div>
<div class=SectionText>
Set the minimum values for velocity of a body that will be considered at rest.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> freezeSpeedMag2
</td>
<td class=DefSep>-</td>
<td class=DefText>
magnitude squared of the velocity threshold.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> freezeOmegaMag2
</td>
<td class=DefSep>-</td>
<td class=DefText>
magnitude squared of angular velocity threshold.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> framesCount
</td>
<td class=DefSep>-</td>
<td class=DefText>
number of frames the body velocity and angular will not excide freezeSpeedMag and freezeOmegaMag.
</td>
</tr>
</table>

<p>   
   <h4>Remarks</h4> Ideally, a body should be deactivated when it reaches a state of stable equilibrium. However, because of floating point 
   inaccuracy, discrete time step simulation and other factors it is virtually impossible for a body to reach that state
   in a real-time simulation. Therefore, in the Newton World, a body is considered to be in stable equilibrium when its 
   velocity and angular velocity fall below some threshold for a consecutive number of frames. 
  
<p>   <h4>Remarks</h4> The default and minimum values for the thresholds is 0.01 for speed and 10 for frames count.
   These values are tuned for single objects colliding under the influence of gravity. It is possible that for complex configuration
   of bodies like multiples pendulums, rag dolls, etc. these values may need to be increased. This is because joints have the property that they
   add a small amount of energy to the system in order to reduce the separation error. This may cause the bodies reach a state of unstable
   equilibrium. That is, when a body oscillates between two different positions because the energy added to the body is equal to the energy
   dissipated by the integrator. This is a situation that is hard to predict, and the best solution is to tweak these values for specific cases. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetAutoFreeze">NewtonBodySetAutoFreeze</a>, <a HREF="#NewtonBodyGetFreezeTreshold">NewtonBodyGetFreezeTreshold</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetFreezeTreshold"></a>
<a NAME="NewtonBodyGetFreezeTreshold"></a>
NewtonBodyGetFreezeTreshold
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyGetFreezeTreshold</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* freezeSpeedMag2,<br> dFloat* freezeOmegaMag2)
</div>
<div class=SectionText>
Get the minimum values for velocity of a body the will be considered at rest.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> freezeSpeedMag2
</td>
<td class=DefSep>-</td>
<td class=DefText>
point the to a dFloat to hold the velocity threshold
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> freezeOmegaMag2
</td>
<td class=DefSep>-</td>
<td class=DefText>
point the to a dFloat to hold the angular velocity threshold
</td>
</tr>
</table>

<p>  
   <h4>See also</h4> <a HREF="#NewtonBodySetFreezeTreshold">NewtonBodySetFreezeTreshold</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetAABB"></a>
<a NAME="NewtonBodyGetAABB"></a>
NewtonBodyGetAABB
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyGetAABB</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* p0,<br> dFloat* p1)	
</div>
<div class=SectionText>
Get the world axis aligned bounding box (AABB) of the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *p0
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold minimum value for the AABB.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *p1
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold maximum value for the AABB.
</td>
</tr>
</table>

<p>  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetVelocity"></a>
<a NAME="NewtonBodySetVelocity"></a>
NewtonBodySetVelocity
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetVelocity</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* velocity)
</div>
<div class=SectionText>
Set the global linear velocity of the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *velocity
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats containing the velocity vector.
</td>
</tr>
</table>

<p>  
   <h4>See also</h4> <a HREF="#NewtonBodyGetVelocity">NewtonBodyGetVelocity</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetVelocity"></a>
<a NAME="NewtonBodyGetVelocity"></a>
NewtonBodyGetVelocity
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyGetVelocity</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* velocity)
</div>
<div class=SectionText>
Get the global linear velocity of the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *velocity
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the velocity vector.
</td>
</tr>
</table>

<p>  
   <h4>See also</h4> <a HREF="#NewtonBodySetVelocity">NewtonBodySetVelocity</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetOmega"></a>
<a NAME="NewtonBodySetOmega"></a>
NewtonBodySetOmega
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetOmega</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* omega)
</div>
<div class=SectionText>
Set the global angular velocity of the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *omega
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats containing the angular velocity vector.
</td>
</tr>
</table>

<p>  
   <h4>See also</h4> <a HREF="#NewtonBodyGetOmega">NewtonBodyGetOmega</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetOmega"></a>
<a NAME="NewtonBodyGetOmega"></a>
NewtonBodyGetOmega
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyGetOmega</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* omega)
</div>
<div class=SectionText>
Get the global angular velocity of the body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *omega
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the angular velocity vector.
</td>
</tr>
</table>

<p>  
   <h4>See also</h4> <a HREF="#NewtonBodySetOmega">NewtonBodySetOmega</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetLinearDamping"></a>
<a NAME="NewtonBodySetLinearDamping"></a>
NewtonBodySetLinearDamping
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodySetLinearDamping</font>(<br> const NewtonBody* bodyPtr,<br> dFloat linearDamp)
</div>
<div class=SectionText>
Apply the linear viscous damping coefficient to the body. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> linearDamp
</td>
<td class=DefSep>-</td>
<td class=DefText>
linear damping coefficient.
</td>
</tr>
</table>

<p>  
   <h4>Remarks</h4> the default value of <b>linearDamp</b> is clamped to a value between 0.0 and 1.0; the default value is 0.1,
   There is a non zero implicit attenuation value of 0.0001 assume by the integrator.
  
<p>   <h4>Remarks</h4> The dampening viscous friction force is added to the external force applied to the body every frame before going to the solver-integrator. 
   This force is proportional to the square of the magnitude of the velocity to the body in the opposite direction of the velocity of the body. 
   An application can set <b>linearDamp</b> to zero when the application takes control of the external forces and torque applied to the body, should the application
   desire to have absolute control of the forces over that body. However, it is recommended that the <b>linearDamp</b> coefficient is set to a non-zero 
   value for the majority of background bodies. This saves the application from having to control these forces and also prevents the integrator from
   adding very large velocities to a body.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetLinearDamping">NewtonBodyGetLinearDamping</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetLinearDamping"></a>
<a NAME="NewtonBodyGetLinearDamping"></a>
NewtonBodyGetLinearDamping
</h3>
<div class=SectionText>
Get the linear viscous damping of the body. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> The linear damping coefficient. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodySetLinearDamping">NewtonBodySetLinearDamping</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodySetAngularDamping"></a>
<a NAME="NewtonBodySetAngularDamping"></a>
NewtonBodySetAngularDamping
</h3>
<div class=SectionText>
Apply the angular viscous damping coefficient to the body. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *angularDamp
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats containing the angular damping coefficients for the principal axis of the body.
</td>
</tr>
</table>

<p>  
   <h4>Remarks</h4> the default value of <b>angularDamp</b> is clamped to a value between 0.0 and 1.0; the default value is 0.1,
   There is a non zero implicit attenuation value of 0.0001 assumed by the integrator.
  
<p>   <h4>Remarks</h4> The dampening viscous friction torque is added to the external torque applied to the body every frame before going to the solver-integrator. 
   This torque is proportional to the square of the magnitude of the angular velocity to the body in the opposite direction of the angular velocity of the body. 
   An application can set <b>angularDamp</b> to zero when the to take control of the external forces and torque applied to the body, should the application
   desire to have absolute control of the forces over that body. However, it is recomended that the <b>linearDamp</b> coefficient be set to a non-zero 
   value for the majority of background bodies. This saves the application from needing to control these forces and also prevents the integrator from
   adding very large velocities to a body.
  
<p>   <h4>See also</h4> <a HREF="#NewtonBodyGetAngularDamping">NewtonBodyGetAngularDamping</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyGetAngularDamping"></a>
<a NAME="NewtonBodyGetAngularDamping"></a>
NewtonBodyGetAngularDamping
</h3>
<div class=Api>
void  <font class=ApiName>NewtonBodyGetAngularDamping</font>(<br> const NewtonBody* bodyPtr,<br> dFloat* angularDamp)
</div>
<div class=SectionText>
Get the linear viscous damping of the body. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *angularDamp
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats to hold the angular damping coefficient for the principal axis of the body.
</td>
</tr>
</table>

<p>  
   <h4>See also</h4> <a HREF="#NewtonBodySetAngularDamping">NewtonBodySetAngularDamping</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBodyForEachPolygonDo"></a>
<a NAME="NewtonBodyForEachPolygonDo"></a>
NewtonBodyForEachPolygonDo
</h3>
<div class=Api>
void <font class=ApiName>NewtonBodyForEachPolygonDo</font>(<br> const NewtonBody* bodyPtr,<br> NewtonCollisionIterator callback)
</div>
<div class=SectionText>
Iterate thought polygon of the collision geometry of a body calling the function callback. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonCollisionIterator</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
application define callback
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
   
<p>   <h4>Remarks</h4> This function can be called by the application in order to show the collision geometry. The application should provide a pointer to the function <b>NewtonCollisionIterator</b>, 
   Newton will convert the collision geometry into a polygonal mesh, and will call <b>callback</b> for every polygon of the mesh
  
<p>   <h4>Remarks</h4> this function affect severely the performance of Newton. The application should call this function only for debugging purpose
  
<p>   <h4>Remarks</h4> This function will ignore user define collision mesh
   See also: <a HREF="#NewtonWorldForEachBodyDo">NewtonWorldForEachBodyDo</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonAddBodyImpulse"></a>
<a NAME="NewtonAddBodyImpulse"></a>
NewtonAddBodyImpulse
</h3>
<div class=Api>
void <font class=ApiName>NewtonAddBodyImpulse</font>(<br> const NewtonBody* bodyPtr,<br> const dFloat* pointDeltaVeloc,<br> const dFloat* pointPosit)
</div>
<div class=SectionText>
Add an impulse to a specific point on a body.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *bodyPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> pointDeltaVeloc
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats containing the desired change in velocity to point pointPosit.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> pointPosit	
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of at least three floats containing the center of the impulse in global space.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
   
<p>   <h4>Remarks</h4> This function will activate the body.
  
<p>   <h4>Remarks</h4> <b>pointPosit</b> and <b>pointDeltaVeloc</b> must be specified in global space.
  
<p>   <h4>Remarks</h4> <b>pointDeltaVeloc</b> represent a change in velocity. For example, a value of <b>pointDeltaVeloc</b> of (1, 0, 0) changes the velocity 
   of <b>bodyPtr</b> in such a way that the velocity of point <b>pointDeltaVeloc</b> will increase by (1, 0, 0)
  
<p>   <h4>Remarks</h4> Because <b>pointDeltaVeloc</b> represents a change in velocity, this function must be used with care. Repeated calls
   to this function will result in an increase of the velocity of the body and may cause to integrator to lose stability.


</div>
</div>
<div class=Section>
<h3>
<a NAME="Ball^and^Socket^joint^interface"></a>
<a NAME="Ball and Socket joint interface"></a>
Ball and Socket joint interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConstraintCreateBall"></a>
<a NAME="NewtonConstraintCreateBall"></a>
NewtonConstraintCreateBall
</h3>
<div class=Api>
NewtonJoint* <font class=ApiName>NewtonConstraintCreateBall</font>(<br> const NewtonWorld* newtonWorld,<br> 
	const dFloat* pivotPoint,<br> 
	const NewtonBody* childBody,<br> 
	const NewtonBody* parentBody)
</div>
<div class=SectionText>
Create a ball an socket joint. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pivotPoint
</td>
<td class=DefSep>-</td>
<td class=DefText>
is origin of ball and socket in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *childBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the attached rigid body, this body can not be NULL or it can not have an infinity (zero) mass.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *parentBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the parent rigid body, this body can be NULL or any kind of rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the ball and socket joint.
  
<p>   <h4>Remarks</h4> This function creates a ball and socket and add it to the world. By default joint disables collision with the linked bodies. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBallSetConeLimits"></a>
<a NAME="NewtonBallSetConeLimits"></a>
NewtonBallSetConeLimits
</h3>
<div class=Api>
void <font class=ApiName>NewtonBallSetConeLimits</font>(<br> const NewtonJoint* ball,<br> const dFloat* pin,<br> dFloat maxConeAngle,<br> dFloat maxTwistAngle)
</div>
<div class=SectionText>
Set the ball and socket cone and twist limits.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *ball
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to a ball and socket joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pin
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a unit vector defining the cone axis in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> maxConeAngle
</td>
<td class=DefSep>-</td>
<td class=DefText>
max angle in radians the attached body is allow to swing relative to the pin axis, a value of zero will disable this limits.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> maxTwistAngle
</td>
<td class=DefSep>-</td>
<td class=DefText>
max angle in radians the attached body is allow to twist relative to the pin axis, a value of zero will disable this limits.
</td>
</tr>
</table>

<p>  
   <h4>Remarks</h4> limits are disabled at creation time. A value of zero for <b>maxConeAngle</b> disable the cone limit, a value of zero for <b>maxTwistAngle</b> disable the twist limit
   all non-zero value for <b>maxConeAngle</b> are clamped between 5 degree and 175 degres   
  
<p>   <h4>See also</h4> <a HREF="#NewtonConstraintCreateBall">NewtonConstraintCreateBall</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBallSetUserCallback"></a>
<a NAME="NewtonBallSetUserCallback"></a>
NewtonBallSetUserCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonBallSetUserCallback</font>(<br> const NewtonJoint* ball,<br> NewtonBallCallBack callback)
</div>
<div class=SectionText>
Set an update call back to be called when either of the two bodies linked by the joint is active.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *ball
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonBallCallBack</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint function call back.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> if the application wants to have some feedback from the joint simulation, the application can register a function
   update callback to be called every time any of the bodies linked by this joint is active. This is useful to provide special
   effects like particles, sound or even to simulate breakable moving parts.
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointSetUserData">NewtonJointSetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBallGetJointAngle"></a>
<a NAME="NewtonBallGetJointAngle"></a>
NewtonBallGetJointAngle
</h3>
<div class=SectionText>
Get the relative joint angle between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *ball
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *angle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats to hold the joint relative Euler angles.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play a bell sound when the joint angle passes some max value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonBallSetUserCallback">NewtonBallSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBallGetJointOmega"></a>
<a NAME="NewtonBallGetJointOmega"></a>
NewtonBallGetJointOmega
</h3>
<div class=Api>
void <font class=ApiName>NewtonBallGetJointOmega</font>(<br> const NewtonJoint* ball,<br> dFloat* omega)
</div>
<div class=SectionText>
Get the relative joint angular velocity between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *ball
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *omega
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats to hold the joint relative angular velocity.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play the creaky noise of a hanging lamp.
   
<p>   <h4>See also</h4> <a HREF="#NewtonBallSetUserCallback">NewtonBallSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonBallGetJointForce"></a>
<a NAME="NewtonBallGetJointForce"></a>
NewtonBallGetJointForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonBallGetJointForce</font>(<br> const NewtonJoint* ball,<br> dFloat* force)
</div>
<div class=SectionText>
Get the total force asserted over the joint pivot point, to maintain the constraint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *ball
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *force
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats to hold the force value of the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can destroy the joint if the force exceeds some predefined value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonBallSetUserCallback">NewtonBallSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Hinge^joint^interface"></a>
<a NAME="Hinge joint interface"></a>
Hinge joint interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConstraintCreateHinge"></a>
<a NAME="NewtonConstraintCreateHinge"></a>
NewtonConstraintCreateHinge
</h3>
<div class=Api>
NewtonJoint* <font class=ApiName>NewtonConstraintCreateHinge</font>(<br> const NewtonWorld* newtonWorld,<br> const dFloat* pivotPoint,<br> const dFloat* pinDir,<br> const NewtonBody* childBody,<br> const NewtonBody* parentBody)
</div>
<div class=SectionText>
Create a hinge joint. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pivotPoint
</td>
<td class=DefSep>-</td>
<td class=DefText>
is origin of the hinge in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pinDir
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the line of action of the hinge in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *childBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the attached rigid body, this body can not be NULL or it can not have an infinity (zero) mass.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *parentBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the parent rigid body, this body can be NULL or any kind of rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the hinge joint.
  
<p>   <h4>Remarks</h4> This function creates a hinge and add it to the world. By default joint disables collision with the linked bodies. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonHingeSetUserCallback"></a>
<a NAME="NewtonHingeSetUserCallback"></a>
NewtonHingeSetUserCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonHingeSetUserCallback</font>(<br> const NewtonJoint* Hinge,<br> NewtonHingeCallBack callback)
</div>
<div class=SectionText>
Set an update call back to be called when either of the two body linked by the joint is active.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Hinge
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonHingeCallBack</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint function call back.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> if the application wants to have some feedback from the joint simulation, the application can register a function
   update callback to be call every time any of the bodies linked by this joint is active. This is useful to provide special
   effects like particles, sound or even to simulate breakable moving parts.
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointGetUserData">NewtonJointGetUserData</a>, <a HREF="#NewtonJointSetUserData">NewtonJointSetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonHingeGetJointAngle"></a>
<a NAME="NewtonHingeGetJointAngle"></a>
NewtonHingeGetJointAngle
</h3>
<div class=SectionText>
Get the relative joint angle between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Hinge
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angle relative to the hinge pin.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play a bell sound when the joint angle passes some max value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonHingeSetUserCallback">NewtonHingeSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonHingeGetJointOmega"></a>
<a NAME="NewtonHingeGetJointOmega"></a>
NewtonHingeGetJointOmega
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonHingeGetJointOmega</font>(const NewtonJoint* Hinge)
</div>
<div class=SectionText>
Get the relative joint angular velocity between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Hinge
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angular velocity relative to the pin axis.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play the creaky noise of a hanging lamp.
   
<p>   <h4>See also</h4> <a HREF="#NewtonHingeSetUserCallback">NewtonHingeSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonHingeGetJointForce"></a>
<a NAME="NewtonHingeGetJointForce"></a>
NewtonHingeGetJointForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonHingeGetJointForce</font>(<br> const NewtonJoint* Hinge,<br> dFloat* force)
</div>
<div class=SectionText>
Calculate the angular acceleration needed to stop the hinge at the desired angle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Hinge
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonHingeSliderUpdateDesc</b> *desc
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to and the Hinge or slide structure.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> angle
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the desired hinge stop angle
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the relative angular acceleration needed to stop the hinge.
  
<p>   <h4>Remarks</h4> this function can only be called from a <b>NewtonHingeCallBack</b> and it can be used by the application to implement hinge limits.
   
<p>   <h4>See also</h4> <a HREF="#NewtonHingeSetUserCallback">NewtonHingeSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonHingeGetJointForce"></a>
<a NAME="NewtonHingeGetJointForce"></a>
NewtonHingeGetJointForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonHingeGetJointForce</font>(<br> const NewtonJoint* Hinge,<br> dFloat* force)
</div>
<div class=SectionText>
Get the total force asserted over the joint pivot point, to maintain the constraint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Hinge
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *force
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats to hold the force value of the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can destroy the joint if the force exceeds some predefined value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonHingeSetUserCallback">NewtonHingeSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Slider^joint^interface"></a>
<a NAME="Slider joint interface"></a>
Slider joint interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConstraintCreateSlider"></a>
<a NAME="NewtonConstraintCreateSlider"></a>
NewtonConstraintCreateSlider
</h3>
<div class=Api>
NewtonJoint* <font class=ApiName>NewtonConstraintCreateSlider</font>(<br> const NewtonWorld* newtonWorld,<br> const dFloat* pivotPoint,<br> const dFloat* pinDir,<br> const NewtonBody* childBody,<br> const NewtonBody* parentBody)
</div>
<div class=SectionText>
Create a slider joint. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pivotPoint
</td>
<td class=DefSep>-</td>
<td class=DefText>
is origin of the slider in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pinDir
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the line of action of the slider in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *childBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the attached rigid body, this body can not be NULL or it can not have an infinity (zero) mass.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *parentBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the parent rigid body, this body can be NULL or any kind of rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the slider joint.
  
<p>   <h4>Remarks</h4> This function creates a slider and add it to the world. By default joint disables collision with the linked bodies. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSliderSetUserCallback"></a>
<a NAME="NewtonSliderSetUserCallback"></a>
NewtonSliderSetUserCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonSliderSetUserCallback</font>(<br> const NewtonJoint* Slider,<br> NewtonSliderCallBack callback)
</div>
<div class=SectionText>
Set an update call back to be called when either of the two body linked by the joint is active.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Slider
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonSliderCallBack</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint function call back.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> if the application wants to have some feedback from the joint simulation, the application can register a function
   update callback to be call every time any of the bodies linked by this joint is active. This is useful to provide special
   effects like particles, sound or even to simulate breakable moving parts.
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointGetUserData">NewtonJointGetUserData</a>, <a HREF="#NewtonJointSetUserData">NewtonJointSetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSliderGetJointPosit"></a>
<a NAME="NewtonSliderGetJointPosit"></a>
NewtonSliderGetJointPosit
</h3>
<div class=SectionText>
Get the relative joint angle between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Slider
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angle relative to the hinge pin.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play a bell sound when the joint angle passes some max value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonSliderSetUserCallback">NewtonSliderSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSliderGetJointVeloc"></a>
<a NAME="NewtonSliderGetJointVeloc"></a>
NewtonSliderGetJointVeloc
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonSliderGetJointVeloc</font>(const NewtonJoint* Slider)
</div>
<div class=SectionText>
Get the relative joint angular velocity between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Slider
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angular velocity relative to the pin axis.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play the creaky noise of a hanging lamp.
   
<p>   <h4>See also</h4> <a HREF="#NewtonSliderSetUserCallback">NewtonSliderSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSliderGetJointForce"></a>
<a NAME="NewtonSliderGetJointForce"></a>
NewtonSliderGetJointForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonSliderGetJointForce</font>(<br> const NewtonJoint* Slider,<br> dFloat* force)
</div>
<div class=SectionText>
Calculate the angular acceleration needed to stop the slider at the desired angle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *slider
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonSliderSliderUpdateDesc</b> *desc
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Slider or slide structure.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> distance
</td>
<td class=DefSep>-</td>
<td class=DefText>
desired stop distance relative to the pivot point
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the relative linear acceleration needed to stop the slider.
  
<p>   <h4>Remarks</h4> this function can only be called from a <b>NewtonSliderCallBack</b> and it can be used by the application to implement slider limits.
   
<p>   <h4>See also</h4> <a HREF="#NewtonSliderSetUserCallback">NewtonSliderSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonSliderGetJointForce"></a>
<a NAME="NewtonSliderGetJointForce"></a>
NewtonSliderGetJointForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonSliderGetJointForce</font>(<br> const NewtonJoint* Slider,<br> dFloat* force)
</div>
<div class=SectionText>
Get the total force asserted over the joint pivot point, to maintain the constraint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Slider
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *force
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats to hold the force value of the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can destroy the joint if the force exceeds some predefined value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonSliderSetUserCallback">NewtonSliderSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Corkscrew^joint^interface"></a>
<a NAME="Corkscrew joint interface"></a>
Corkscrew joint interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConstraintCreateCorkscrew"></a>
<a NAME="NewtonConstraintCreateCorkscrew"></a>
NewtonConstraintCreateCorkscrew
</h3>
<div class=Api>
NewtonJoint* <font class=ApiName>NewtonConstraintCreateCorkscrew</font>(<br> const NewtonWorld* newtonWorld,<br> const dFloat* pivotPoint,<br> const dFloat* pinDir,<br> const NewtonBody* childBody,<br> const NewtonBody* parentBody)
</div>
<div class=SectionText>
Create a corkscrew joint. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pivotPoint
</td>
<td class=DefSep>-</td>
<td class=DefText>
is origin of the corkscrew in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pinDir
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the line of action of the corkscrew in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *childBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the attached rigid body, this body can not be NULL or it can not have an infinity (zero) mass.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *parentBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the parent rigid body, this body can be NULL or any kind of rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the corkscrew joint.
  
<p>   <h4>Remarks</h4> This function creates a corkscrew and add it to the world. By default joint disables collision with the linked bodies. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCorkscrewSetUserCallback"></a>
<a NAME="NewtonCorkscrewSetUserCallback"></a>
NewtonCorkscrewSetUserCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonCorkscrewSetUserCallback</font>(<br> const NewtonJoint* Corkscrew,<br> NewtonCorkscrewCallBack callback)
</div>
<div class=SectionText>
Set an update call back to be called when either of the two body linked by the joint is active.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Corkscrew
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonCorkscrewCallBack</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint function call back.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> if the application wants to have some feedback from the joint simulation, the application can register a function
   update callback to be call every time any of the bodies linked by this joint is active. This is useful to provide special
   effects like particles, sound or even to simulate breakable moving parts.
  
<p>   <h4>Remarks</h4> the function <b>NewtonCorkscrewCallBack callback</b> should return a bit field code.
   if the application does not want to set the joint acceleration the return code is zero
   if the application only wants to change the joint linear acceleration the return code is 1
   if the application only wants to change the joint angular acceleration the return code is 2
   if the application only wants to change the joint angular and linear acceleration the return code is 3
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointGetUserData">NewtonJointGetUserData</a>, <a HREF="#NewtonJointSetUserData">NewtonJointSetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCorkscrewGetJointPosit"></a>
<a NAME="NewtonCorkscrewGetJointPosit"></a>
NewtonCorkscrewGetJointPosit
</h3>
<div class=SectionText>
Get the relative joint angle between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Corkscrew
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angle relative to the hinge pin.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play a bell sound when the joint angle passes some max value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonCorkscrewSetUserCallback">NewtonCorkscrewSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCorkscrewGetJointVeloc"></a>
<a NAME="NewtonCorkscrewGetJointVeloc"></a>
NewtonCorkscrewGetJointVeloc
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonCorkscrewGetJointVeloc</font>(const NewtonJoint* Corkscrew)
</div>
<div class=SectionText>
Get the relative joint angular velocity between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Corkscrew
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angular velocity relative to the pin axis.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play the creaky noise of a hanging lamp.
   
<p>   <h4>See also</h4> <a HREF="#NewtonCorkscrewSetUserCallback">NewtonCorkscrewSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCorkscrewGetJointAngle"></a>
<a NAME="NewtonCorkscrewGetJointAngle"></a>
NewtonCorkscrewGetJointAngle
</h3>
<div class=SectionText>
Get the relative joint angle between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Corkscrew
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angle relative to the corkscrew pin.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play a bell sound when the joint angle passes some max value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonCorkscrewSetUserCallback">NewtonCorkscrewSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCorkscrewGetJointOmega"></a>
<a NAME="NewtonCorkscrewGetJointOmega"></a>
NewtonCorkscrewGetJointOmega
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonCorkscrewGetJointOmega</font>(const NewtonJoint* Corkscrew)
</div>
<div class=SectionText>
Get the relative joint angular velocity between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Corkscrew
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angular velocity relative to the pin axis.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play the creaky noise of a hanging lamp.
   
<p>   <h4>See also</h4> <a HREF="#NewtonCorkscrewSetUserCallback">NewtonCorkscrewSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCorkscrewCalculateStopAlpha"></a>
<a NAME="NewtonCorkscrewCalculateStopAlpha"></a>
NewtonCorkscrewCalculateStopAlpha
</h3>
<div class=SectionText>
Calculate the angular acceleration needed to stop the corkscrew at the desired angle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Corkscrew
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonCorkscrewSliderUpdateDesc</b> *desc
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Corkscrew or slide structure.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> angle
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the desired corkscrew stop angle
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the relative angular acceleration needed to stop the corkscrew.
  
<p>   <h4>Remarks</h4> this function can only be called from a <b>NewtonCorkscrewCallBack</b> and it can be used by the application to implement corkscrew limits.
   
<p>   <h4>See also</h4> <a HREF="#NewtonCorkscrewSetUserCallback">NewtonCorkscrewSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCorkscrewGetJointForce"></a>
<a NAME="NewtonCorkscrewGetJointForce"></a>
NewtonCorkscrewGetJointForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonCorkscrewGetJointForce</font>(<br> const NewtonJoint* Corkscrew,<br> dFloat* force)
</div>
<div class=SectionText>
Calculate the angular acceleration needed to stop the corkscrew at the desired angle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *corkscrew
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonCorkscrewCorkscrewUpdateDesc</b> *desc
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Corkscrew or slide structure.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> distance
</td>
<td class=DefSep>-</td>
<td class=DefText>
desired stop distance relative to the pivot point
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the relative linear acceleration needed to stop the corkscrew.
  
<p>   <h4>Remarks</h4> this function can only be called from a <b>NewtonCorkscrewCallBack</b> and it can be used by the application to implement corkscrew limits.
   
<p>   <h4>See also</h4> <a HREF="#NewtonCorkscrewSetUserCallback">NewtonCorkscrewSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCorkscrewGetJointForce"></a>
<a NAME="NewtonCorkscrewGetJointForce"></a>
NewtonCorkscrewGetJointForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonCorkscrewGetJointForce</font>(<br> const NewtonJoint* Corkscrew,<br> dFloat* force)
</div>
<div class=SectionText>
Get the total force asserted over the joint pivot point, to maintain the constraint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Corkscrew
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *force
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats to hold the force value of the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can destroy the joint if the force exceeds some predefined value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonCorkscrewSetUserCallback">NewtonCorkscrewSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Universal^joint^interface"></a>
<a NAME="Universal joint interface"></a>
Universal joint interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConstraintCreateUniversal"></a>
<a NAME="NewtonConstraintCreateUniversal"></a>
NewtonConstraintCreateUniversal
</h3>
<div class=Api>
NewtonJoint* <font class=ApiName>NewtonConstraintCreateUniversal</font>(<br> const NewtonWorld* newtonWorld,<br> const dFloat* pivotPoint,<br> 
	const dFloat* pinDir0,<br> const dFloat* pinDir1,<br> const NewtonBody* childBody,<br> const NewtonBody* parentBody)
</div>
<div class=SectionText>
Create a universal joint. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pivotPoint
</td>
<td class=DefSep>-</td>
<td class=DefText>
is origin of the universal joint in global space.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pinDir0
</td>
<td class=DefSep>-</td>
<td class=DefText>
first axis of rotation fixed on childBody body and perpendicular to pinDir1.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pinDir1
</td>
<td class=DefSep>-</td>
<td class=DefText>
second axis of rotation fixed on parentBody body and perpendicular to pinDir0.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *childBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the attached rigid body, this body can not be NULL or it can not have an infinity (zero) mass.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *parentBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the parent rigid body, this body can be NULL or any kind of rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the universal joint.
  
<p>   <h4>Remarks</h4> This function creates a universal joint and add it to the world. By default joint disables collision with the linked bodies. 
  
<p>   <h4>Remark</h4> a universal joint is a constraint that restricts twp rigid bodies to be connected to a point fixed on both bodies, 
   while and allowing one body to spin around a fix axis in is own frame, and the other body to spin around another axis fixes on 
   it own frame. Both axis must be mutually perpendicular. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUniversalSetUserCallback"></a>
<a NAME="NewtonUniversalSetUserCallback"></a>
NewtonUniversalSetUserCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonUniversalSetUserCallback</font>(<br> const NewtonJoint* Universal,<br> NewtonUniversalCallBack callback)
</div>
<div class=SectionText>
Set an update call back to be called when either of the two body linked by the joint is active.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Universal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonUniversalCallBack</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint function call back.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> if the application wants to have some feedback from the joint simulation, the application can register a function
   update callback to be called every time any of the bodies linked by this joint is active. This is useful to provide special
   effects like particles, sound or even to simulate breakable moving parts.
  
<p>   <h4>Remarks</h4> the function <b>NewtonUniversalCallBack callback</b> should return a bit field code.
   if the application does not want to set the joint acceleration the retur code is zero
   if the application only wants to change the joint linear acceleration the return code is 1
   if the application only wants to change the joint angular acceleration the return code is 2
   if the application only wants to change the joint angular and linear acceleration the return code is 3
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointGetUserData">NewtonJointGetUserData</a>, <a HREF="#NewtonJointSetUserData">NewtonJointSetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUniversalGetJointAngle0"></a>
<a NAME="NewtonUniversalGetJointAngle0"></a>
NewtonUniversalGetJointAngle0
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonUniversalGetJointAngle0</font>(const NewtonJoint* Universal)
</div>
<div class=SectionText>
Get the relative joint angle between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Universal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angle relative to the universal pin0.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play a bell sound when the joint angle passes some max value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonUniversalSetUserCallback">NewtonUniversalSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUniversalGetJointAngle1"></a>
<a NAME="NewtonUniversalGetJointAngle1"></a>
NewtonUniversalGetJointAngle1
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonUniversalGetJointAngle1</font>(const NewtonJoint* Universal)
</div>
<div class=SectionText>
Get the relative joint angle between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Universal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angle relative to the universal pin1.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play a bell sound when the joint angle passes some max value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonUniversalSetUserCallback">NewtonUniversalSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUniversalGetJointOmega0"></a>
<a NAME="NewtonUniversalGetJointOmega0"></a>
NewtonUniversalGetJointOmega0
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonUniversalGetJointOmega0</font>(const NewtonJoint* Universal)
</div>
<div class=SectionText>
Get the relative joint angular velocity between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Universal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angular velocity relative to the pin0 axis.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play the creaky noise of a hanging lamp.
   
<p>   <h4>See also</h4> <a HREF="#NewtonUniversalSetUserCallback">NewtonUniversalSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUniversalGetJointOmega1"></a>
<a NAME="NewtonUniversalGetJointOmega1"></a>
NewtonUniversalGetJointOmega1
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonUniversalGetJointOmega1</font>(const NewtonJoint* Universal)
</div>
<div class=SectionText>
Get the relative joint angular velocity between the two bodies.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Universal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the joint angular velocity relative to the pin1 axis.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can play the creaky noise of a hanging lamp.
   
<p>   <h4>See also</h4> <a HREF="#NewtonUniversalSetUserCallback">NewtonUniversalSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUniversalCalculateStopAlpha0"></a>
<a NAME="NewtonUniversalCalculateStopAlpha0"></a>
NewtonUniversalCalculateStopAlpha0
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonUniversalCalculateStopAlpha0</font>(<br> const NewtonJoint* universal,<br> const NewtonHingeSliderUpdateDesc* desc,<br> dFloat angle)
</div>
<div class=SectionText>
Calculate the angular acceleration needed to stop the universal at the desired angle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Universal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonUniversalSliderUpdateDesc</b> *desc
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Universal or slide structure.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> angle
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the desired universal stop angle rotation around pin0
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the relative angular acceleration needed to stop the universal.
  
<p>   <h4>Remarks</h4> this function can only be called from a <b>NewtonUniversalCallBack</b> and it can be used by the application to implement universal limits.
   
<p>   <h4>See also</h4> <a HREF="#NewtonUniversalSetUserCallback">NewtonUniversalSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUniversalCalculateStopAlpha1"></a>
<a NAME="NewtonUniversalCalculateStopAlpha1"></a>
NewtonUniversalCalculateStopAlpha1
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonUniversalCalculateStopAlpha1</font>(<br> const NewtonJoint* universal,<br> const NewtonHingeSliderUpdateDesc* desc,<br> dFloat angle)
</div>
<div class=SectionText>
Calculate the angular acceleration needed to stop the universal at the desired angle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Universal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonUniversalSliderUpdateDesc</b> *desc
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to and the Universal or slide structure.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> angle
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the desired universal stop angle rotation around pin1
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the relative angular acceleration needed to stop the universal.
  
<p>   <h4>Remarks</h4> this function can only be called from a <b>NewtonUniversalCallBack</b> and it can be used by the application to implement universal limits.
   
<p>   <h4>See also</h4> <a HREF="#NewtonUniversalSetUserCallback">NewtonUniversalSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUniversalGetJointForce"></a>
<a NAME="NewtonUniversalGetJointForce"></a>
NewtonUniversalGetJointForce
</h3>
<div class=Api>
void <font class=ApiName>NewtonUniversalGetJointForce</font>(<br> const NewtonJoint* Universal,<br> dFloat* force)
</div>
<div class=SectionText>
Get the total force asserted over the joint pivot point, to maintain the constraint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *Universal
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *force
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats to hold the force value of the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> this function can be used during a function update call back to provide the application with some special effect.
   for example the application can destroy the joint if the force exceeds some predefined value.
   
<p>   <h4>See also</h4> <a HREF="#NewtonUniversalSetUserCallback">NewtonUniversalSetUserCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="UpVector^joint^Interface"></a>
<a NAME="UpVector joint Interface"></a>
UpVector joint Interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConstraintCreateUpVector"></a>
<a NAME="NewtonConstraintCreateUpVector"></a>
NewtonConstraintCreateUpVector
</h3>
<div class=SectionText>
Create a UpVector joint. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *pinDir
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the aligning vector.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *body
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the attached rigid body, this body can not be NULL or it can not have an infinity (zero) mass.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the up vector joint.
  
<p>   <h4>Remarks</h4> This function creates an up vector joint. An up vector joint is a constraint that allows a body to translate freely in 3d space,
   but it only allows the body to rotate around the pin direction vector. This could be use by the application to control a character 
   with physics and collision.
  
<p>   <h4>Remark</h4> Since the UpVector joint is a unary constraint, there is not need to have user callback or user data assigned to it.
   The application can simple hold to the joint handle and update the pin on the force callback function of the rigid body owning the joint.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUpVectorGetPin"></a>
<a NAME="NewtonUpVectorGetPin"></a>
NewtonUpVectorGetPin
</h3>
<div class=Api>
void <font class=ApiName>NewtonUpVectorGetPin</font>(<br> const NewtonJoint* upVector,<br> dFloat *pin)
</div>
<div class=SectionText>
Get the up vector pin of this joint in global space.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *upVector
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *pin
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats to hold the up vector direction in global space.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> the application ca call this function to read the up vector, this is useful to animate the up vector.
   if the application is going to animated the up vector, it must do so by applying only small rotation, 
   too large rotation can cause vibration of the joint.
   
<p>   <h4>See also</h4> NewtonUpVectorSetUserCallback, <a HREF="#NewtonUpVectorSetPin">NewtonUpVectorSetPin</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUpVectorSetPin"></a>
<a NAME="NewtonUpVectorSetPin"></a>
NewtonUpVectorSetPin
</h3>
<div class=Api>
void <font class=ApiName>NewtonUpVectorSetPin</font>(<br> const NewtonJoint* upVector,<br> const dFloat *pin)
</div>
<div class=SectionText>
Set the up vector pin of this joint in global space.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *upVector
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *pin
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of a least three floats containing the up vector direction in global space.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> the application ca call this function to change the joint up vector, this is useful to animate the up vector.
   if the application is going to animated the up vector, it must do so by applying only small rotation, 
   too large rotation can cause vibration of the joint.
   
<p>   <h4>See also</h4> NewtonUpVectorSetUserCallback, <a HREF="#NewtonUpVectorGetPin">NewtonUpVectorGetPin</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="User^defined^joint^interface"></a>
<a NAME="User defined joint interface"></a>
User defined joint interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConstraintCreateUserJoint"></a>
<a NAME="NewtonConstraintCreateUserJoint"></a>
NewtonConstraintCreateUserJoint
</h3>
<div class=Api>
NewtonJoint* <font class=ApiName>NewtonConstraintCreateUserJoint</font>(<br> const NewtonWorld* newtonWorld,<br> int maxDOF,<br> NewtonUserBilateralCallBack callback,<br> const NewtonBody* childBody,<br> const NewtonBody* parentBody)
</div>
<div class=SectionText>
Create a user define bilateral joint. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>    
<tr class=Def>
<td class=Def>
in*t maxDOF
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the maximum number of degree of freedom controlled by this joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonUpVectorCallBack</b> callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint function call back.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *childBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the attached rigid body, this body can not be NULL or it can not have an infinity (zero) mass.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *parentBody
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the parent rigid body, this body can be NULL or any kind of rigid body.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> Bilateral joint are constraints that can have up to 6 degree of freedoms, 3 linear and 3 angular. 
   By restricting the motion along any number of these degree of freedom a very large number of useful joint between 
   two rigid bodies can be accomplished. Some of the degree of freedoms restriction makes no sense, and also some 
   combinations are so rare that only make sense to a very specific application, the Newton engine implements the more 
   commons combinations like, hinges, ball and socket, etc. However if and application is in the situation that any of 
   the provided joints can achieve the desired effect, then the application can design it own joint.
  
<p>   <h4>Remark</h4> User defined joint is a very advance feature that should be look at, only for very especial situations. 
   The designer must be a person with a very good understanding of constrained dynamics, and it may be the case 
   that many trial have to be made before a good result can be accomplished.
  
<p>   <h4>Remark</h4> maxDOF is and upper bound as to how many degrees of freedoms the joint can control, usually this value 
   can be 6 for bilateral joints, but it can be higher for special joints like vehicles where by the used of friction clamping
   the number of rows can be higher.
   In general the application should determine maxDof correctly, passing an unnecessary excessive value will lead to performance decreased.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointAddLinearRow"></a>
<a NAME="NewtonUserJointAddLinearRow"></a>
NewtonUserJointAddLinearRow
</h3>
<div class=Api>
void <font class=ApiName>NewtonUserJointAddLinearRow</font>(<br> const NewtonJoint* joint,<br> const dFloat *pivot0,<br> const dFloat *pivot1,<br> const dFloat *dir)
</div>
<div class=SectionText>
Add a linear restricted degree of freedom. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *pivot0
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer of a vector in global space fixed on body zero.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *pivot1
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer of a vector in global space fixed on body one.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *pin
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer of a unit vector in global space along which the relative position, velocity and acceleration between the bodies will be driven to zero.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> A linear contraint row calculates the Jacobian derivatives and relative acceleration required to enforce the constraint condition at
   the attachment point and the pin direction considered fixed to both bodies. 
  
<p>   <h4>Remark</h4> The acceleration is calculated such that the relative linear motion between the two points is zero, the application can
   afterward override this value to create motors.
   
<p>   <h4>Remark</h4> after this function is call and internal DOF index will point to the current row entry in the constraint matrix.
  
<p>   <h4>Remark</h4> This function call only be called from inside a <b>NewtonUserBilateralCallBack</b> callback.
  
<p>   <h4>See also</h4> <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>,  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointAddAngularRow"></a>
<a NAME="NewtonUserJointAddAngularRow"></a>
NewtonUserJointAddAngularRow
</h3>
<div class=Api>
void <font class=ApiName>NewtonUserJointAddAngularRow</font>(<br> const NewtonJoint* joint,<br> dFloat relativeAngleError,<br> const dFloat *pin)
</div>
<div class=SectionText>
Add an angular restricted degree of freedom. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> relativeAngleError
</td>
<td class=DefSep>-</td>
<td class=DefText>
relative angle error between both bodies around pin axis.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *pin
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer of a unit vector in global space along which the relative position, velocity and acceleration between the bodies will be driven to zero.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> An angular contraint row calculates the Jacobian derivatives and relative acceleration required to enforce the constraint condition at
   pin direction considered fixed to both bodies. 
  
<p>   <h4>Remark</h4> The acceleration is calculated such that the relative angular motion between the two points is zero, The application can
   afterward override this value to create motors.
   
<p>   <h4>Remark</h4> After this function is called and internal DOF index will point to the current row entry in the constraint matrix.
  
<p>   <h4>Remark</h4> This function call only be called from inside a <b>NewtonUserBilateralCallBack</b> callback.
  
<p>   <h4>Remark</h4> This function is of not practical to enforce hard constraints, but it is very useful for making angular motors.
  
<p>   <h4>See also</h4> <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a>, NewtonUserJointAddIndependentAngularRow  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointAddGeneralRow"></a>
<a NAME="NewtonUserJointAddGeneralRow"></a>
NewtonUserJointAddGeneralRow
</h3>
<div class=Api>
void <font class=ApiName>NewtonUserJointAddGeneralRow</font>(<br> const NewtonJoint* joint,<br> const dFloat *jacobian0,<br> const dFloat *jacobian1)
</div>
<div class=SectionText>
set the general linear and angular Jacobian for the desired degree of freedom  
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *jacobian0
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer of a set of six values defining the linear and angular Jacobian for body0.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *jacobian1
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer of a set of six values defining the linear and angular Jacobian for body1.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> In general this function must be used for very special effects and in combination with other joints. 
   it is expected that the user have a knowledge of Constrained dynamics to make a good used of this function.
   Must typical application of this function are the creation of synchronization or control joints like gears, pulleys, 
   worm gear and some other mechanical control.
  
<p>   <h4>Remark</h4> this function set the relative acceleration for this degree of freedom to zero. It is the 
   application responsibility to set the relative acceleration after a call to this function
   
<p>   <h4>See also</h4> <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a>, <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointSetRowMaximumFriction"></a>
<a NAME="NewtonUserJointSetRowMaximumFriction"></a>
NewtonUserJointSetRowMaximumFriction
</h3>
<div class=Api>
void <font class=ApiName>NewtonUserJointSetRowMaximumFriction</font>(<br> const NewtonJoint* joint,<br> dFloat friction)
</div>
<div class=SectionText>
Set the maximum friction value the solver is allow to apply to the joint row. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> friction
</td>
<td class=DefSep>-</td>
<td class=DefText>
maximum friction value for this row. It must be a positive value between 0.0 and INFINITY.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> This function will override the default friction values set after a call to <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a> or <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>.
   friction value is context sensitive, if for linear constraint friction is a Max friction force, for angular constraint friction is a 
   max friction is a Max friction torque.
  
<p>   <h4>See also</h4> <a HREF="#NewtonUserJointSetRowMinimumFriction">NewtonUserJointSetRowMinimumFriction</a>, <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a>, <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointSetRowMinimumFriction"></a>
<a NAME="NewtonUserJointSetRowMinimumFriction"></a>
NewtonUserJointSetRowMinimumFriction
</h3>
<div class=Api>
void <font class=ApiName>NewtonUserJointSetRowMinimumFriction</font>(<br> const NewtonJoint* joint,<br> dFloat friction)
</div>
<div class=SectionText>
Set the minimum friction value the solver is allow to apply to the joint row. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> friction
</td>
<td class=DefSep>-</td>
<td class=DefText>
friction value for this row. It must be a negative value between 0.0 and -INFINITY.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> This function will override the default friction values set after a call to <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a> or <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>.
   friction value is context sensitive, if for linear constraint friction is a Min friction force, for angular constraint friction is a 
   friction is a Min friction torque.
  
<p>   <h4>See also</h4> <a HREF="#NewtonUserJointSetRowMaximumFriction">NewtonUserJointSetRowMaximumFriction</a>, <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a>, <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointSetRowAcceleration"></a>
<a NAME="NewtonUserJointSetRowAcceleration"></a>
NewtonUserJointSetRowAcceleration
</h3>
<div class=Api>
void <font class=ApiName>NewtonUserJointSetRowAcceleration</font>(<br> const NewtonJoint* joint,<br> dFloat acceleration)
</div>
<div class=SectionText>
Set the value for the desired acceleration for the current constraint row. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> acceleration
</td>
<td class=DefSep>-</td>
<td class=DefText>
desired acceleration value for this row.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> This function will override the default acceleration values set after a call to <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a> or <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>.
   friction value is context sensitive, if for linear constraint acceleration is a linear acceleration, for angular constraint acceleration is an 
   angular acceleration.
  
<p>   <h4>See also</h4> <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a>, <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>   


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointSetRowSpringDamperAcceleration"></a>
<a NAME="NewtonUserJointSetRowSpringDamperAcceleration"></a>
NewtonUserJointSetRowSpringDamperAcceleration
</h3>
<div class=Api>
void <font class=ApiName>NewtonUserJointSetRowSpringDamperAcceleration</font>(<br> const NewtonJoint* joint,<br> dFloat springK,<br> dFloat springD)
</div>
<div class=SectionText>
Calculates the row acceleration to satisfy the specified the spring damper system. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> springK
</td>
<td class=DefSep>-</td>
<td class=DefText>
desired spring stiffness, it must be a positive value.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> springD
</td>
<td class=DefSep>-</td>
<td class=DefText>
desired spring damper, it must be a positive value.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> This function will override the default acceleration values set after a call to <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a> or <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>.
   friction value is context sensitive, if for linear constraint acceleration is a linear acceleration, for angular constraint acceleration is an 
   angular acceleration.
  
<p>   <h4>Remark</h4> the acceleration calculated by this function represent the mass, spring system of the form
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
a = -ks * x
</td>
<td class=DefSep>-</td>
<td class=DefText>
kd * v.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> for this function to take place the joint stiffness must be set to a values lower than 1.0
  
<p>   <h4>See also</h4> <a HREF="#NewtonUserJointSetRowAcceleration">NewtonUserJointSetRowAcceleration</a>, <a HREF="#NewtonUserJointSetRowStiffness">NewtonUserJointSetRowStiffness</a>  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointSetRowStiffness"></a>
<a NAME="NewtonUserJointSetRowStiffness"></a>
NewtonUserJointSetRowStiffness
</h3>
<div class=Api>
void <font class=ApiName>NewtonUserJointSetRowStiffness</font>(<br> const NewtonJoint* joint,<br> dFloat stiffness)
</div>
<div class=SectionText>
Set the maximum percentage of the constraint force that will be applied to the constraint row. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> stiffness
</td>
<td class=DefSep>-</td>
<td class=DefText>
row stiffness, it must be a values between 0.0 and 1.0, the default is 0.9.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> This function will override the default stiffness value set after a call to <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a> or <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>.
   the row stiffness is the percentage of the constraint force that will be applied to the rigid bodies. Ideally the value should be
   1.0 (100% stiff) but dues to numerical integration error this could be the joint a little unstable, and lower values are preferred.
  
<p>   <h4>See also</h4> <a HREF="#NewtonUserJointAddLinearRow">NewtonUserJointAddLinearRow</a>, <a HREF="#NewtonUserJointAddAngularRow">NewtonUserJointAddAngularRow</a>, <a HREF="#NewtonUserJointSetRowSpringDamperAcceleration">NewtonUserJointSetRowSpringDamperAcceleration</a>  


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonUserJointGetRowForce"></a>
<a NAME="NewtonUserJointGetRowForce"></a>
NewtonUserJointGetRowForce
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonUserJointGetRowForce</font>(<br> const NewtonJoint* joint,<br> int row)
</div>
<div class=SectionText>
Return the magnitude previews force or torque value calculated by the solver for this contraint row. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b>  row
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to the constraint row.
</td>
</tr>
</table>

<p>  
   <h4>Remark</h4> This function can be call for any of the previews row for this particular joint, The application must keep track of the meaning of the row.
   
<p>   <h4>Remark</h4> This function can be used to produce special effects like breakable or malleable joints, fro example a hinge can turn into ball and sockect 
   after the force in some of the row excide certain high value. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="Joint^common^function^s"></a>
<a NAME="Joint common function s"></a>
Joint common function s
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonJointSetUserData"></a>
<a NAME="NewtonJointSetUserData"></a>
NewtonJointSetUserData
</h3>
<div class=Api>
void <font class=ApiName>NewtonJointSetUserData</font>(<br> const NewtonJoint* joint,<br> void* userData)
</div>
<div class=SectionText>
Store a user defined data value with the joint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userDataPtr
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the user defined user data value.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The application can store a user defined value with the Joint. This value can be the pointer to a structure containing some application data for special effect. 
   if the application allocate some resource to store the user data, the application can register a joint destructor to get rid of the allocated resource when the Joint is destroyed
   
<p>   <h4>See also</h4> NewtonConstraintCreateJoint, <a HREF="#NewtonJointSetDestructor">NewtonJointSetDestructor</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonJointGetUserData"></a>
<a NAME="NewtonJointGetUserData"></a>
NewtonJointGetUserData
</h3>
<div class=Api>
void* <font class=ApiName>NewtonJointGetUserData</font>(const NewtonJoint* joint)
</div>
<div class=SectionText>
Retrieve a user defined data value stored with the joint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> The user defined data.
  
<p>   <h4>Remarks</h4> The application can store a user defined value with a joint. This value can be the pointer
   to a structure to store some game play data for special effect.
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointSetUserData">NewtonJointSetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonJointSetCollisionState"></a>
<a NAME="NewtonJointSetCollisionState"></a>
NewtonJointSetCollisionState
</h3>
<div class=Api>
void <font class=ApiName>NewtonJointSetCollisionState</font>(<br> const NewtonJoint* joint,<br> int state)
</div>
<div class=SectionText>
Enable or disable collision between the two bodies linked by this joint. The default state is collision disable when the joint is created.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> state
</td>
<td class=DefSep>-</td>
<td class=DefText>
collision state, zero mean disable collision, non zero enable collision between linked bodies.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> usually when two bodies are linked by a joint, the application wants collision between this two bodies to be disabled. 
   This is the default behavior of joints when they are created, however when this behavior is not desired the application can change
   it by setting collision on. If the application decides to enable collision between jointed bodies, the application should make sure the 
   collision geometry do not collide in the work space of the joint.
  
<p>   <h4>Remarks</h4> if the joint is destroyed the collision state of the two bodies linked by this joint is determined by the material pair assigned to each body.
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointGetCollisionState">NewtonJointGetCollisionState</a>, <a HREF="#NewtonBodySetJointRecursiveCollision">NewtonBodySetJointRecursiveCollision</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonJointGetCollisionState"></a>
<a NAME="NewtonJointGetCollisionState"></a>
NewtonJointGetCollisionState
</h3>
<div class=Api>
int <font class=ApiName>NewtonJointGetCollisionState</font>(const NewtonJoint* joint)
</div>
<div class=SectionText>
Get the collision state of the two bodies linked by the joint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the collision state.
  
<p>   <h4>Remarks</h4> usually when two bodies are linked by a joint, the application wants collision between this two bodies to be disabled. 
   This is the default behavior of joints when they are created, however when this behavior is not desired the application can change
   it by setting collision on. If the application decides to enable collision between jointed bodies, the application should make sure the 
   collision geometry do not collide in the work space of the joint.
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointSetCollisionState">NewtonJointSetCollisionState</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonJointSetStiffness"></a>
<a NAME="NewtonJointSetStiffness"></a>
NewtonJointSetStiffness
</h3>
<div class=Api>
void <font class=ApiName>NewtonJointSetStiffness</font>(<br> const NewtonJoint* joint,<br> dFloat stiffness)
</div>
<div class=SectionText>
Set the strength coeficient to be applied to the joint reaction forces.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> stiffness
</td>
<td class=DefSep>-</td>
<td class=DefText>
stiffness coeficient, a value between 0, and 1.0, the default value for most joint is 0.9
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> Constraint keep bodies together by calculating the exact force necessary to cancel the relative acceleration between one or 
   more common points fixed in the two bodies. The problem is that when the bodies drift apart due to numerical integration inaccuracies, 
   the reaction force work to pull eliminated the error but at the expense of adding extra energy to the system, does violating the rule 
   that constraint forces must be work less. This is a inevitable situation and the only think we can do is to minimize the effect of the 
   extra energy by dampening the force by some amount. In essence the stiffness coefficient tell Newton calculate the precise reaction force 
   by only apply a fraction of it to the joint point. And value of 1.0 will apply the exact force, and a value of zero will apply only 
   10 percent. 
  
<p>   <h4>Remark</h4> The stiffness is set to a all around value that work well for most situation, however the application can play with these 
   parameter to make finals adjustment. A high value will make the joint stronger but more prompt to vibration of instability; a low 
   value will make the joint more stable but weaker.  
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointGetStiffness">NewtonJointGetStiffness</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonJointGetStiffness"></a>
<a NAME="NewtonJointGetStiffness"></a>
NewtonJointGetStiffness
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonJointGetStiffness</font>(const NewtonJoint* joint)
</div>
<div class=SectionText>
Get the strength coefficient bing applied to the joint reaction forces.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> stiffness
</td>
<td class=DefSep>-</td>
<td class=DefText>
stiffness coeficient, a value between 0, and 1.0, the default value for most joint is 0.9
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> stiffness coeficient.
  
<p>   <h4>Remarks</h4> Constraint keep bodies together by calculating the exact force necessary to cancel the relative acceleration between one or 
   more common points fixed in the two bodies. The problem is that when the bodies drift apart due to numerical integration inaccuracies, 
   the reaction force work to pull eliminated the error but at the expense of adding extra energy to the system, does violating the rule 
   that constraint forces must be work less. This is a inevitable situation and the only think we can do is to minimize the effect of the 
   extra energy by dampening the force by some amount. In essence the stiffness coefficient tell Newton calculate the precise reaction force 
   by only apply a fraction of it to the joint point. And value of 1.0 will apply the exact force, and a value of zero will apply only 
   10 percent. 
  
<p>   <h4>Remark</h4> The stiffness is set to a all around value that work well for most situation, however the application can play with these 
   parameter to make finals adjustment. A high value will make the joint stronger but more prompt to vibration of instability; a low 
   value will make the joint more stable but weaker.  
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointSetStiffness">NewtonJointSetStiffness</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonJointSetDestructor"></a>
<a NAME="NewtonJointSetDestructor"></a>
NewtonJointSetDestructor
</h3>
<div class=Api>
void <font class=ApiName>NewtonJointSetDestructor</font>(<br> const NewtonJoint* joint,<br> NewtonConstraintDestructor destructor)
</div>
<div class=SectionText>
Register a destructor callback to be called when the joint is about to be destroyed.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonJointCallBack</b> destructor
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the joint destructor callback.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> If application stores any resource with the joint, or the application wants to be notified when the
   joint is about to be destroyed. The application can register a destructor call back with the joint.
   
<p>   <h4>See also</h4> <a HREF="#NewtonJointSetUserData">NewtonJointSetUserData</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonDestroyJoint"></a>
<a NAME="NewtonDestroyJoint"></a>
NewtonDestroyJoint
</h3>
<div class=Api>
void <font class=ApiName>NewtonDestroyJoint</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonJoint* joint)
</div>
<div class=SectionText>
destroy a joint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *joint
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to joint to be destroyed
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
   
<p>   <h4>Remarks</h4> The application can call this function when it wants to destroy a joint. This function can be used by the application to simulate
   breakable joints
  
<p>   <h4>See also</h4> NewtonConstraintCreateJoint, <a HREF="#NewtonConstraintCreateHinge">NewtonConstraintCreateHinge</a>, <a HREF="#NewtonConstraintCreateSlider">NewtonConstraintCreateSlider</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="Rag^doll^joint^container^Interface"></a>
<a NAME="Rag doll joint container Interface"></a>
Rag doll joint container Interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonCreateRagDoll"></a>
<a NAME="NewtonCreateRagDoll"></a>
NewtonCreateRagDoll
</h3>
<div class=Api>
NewtonRagDoll* <font class=ApiName>NewtonCreateRagDoll</font>(const NewtonWorld* newtonWorld)
</div>
<div class=SectionText>
Create an empty rag doll container.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> handle to an empty rag doll container.
  
<p>   <h4>Remarks</h4> A rag doll container is the encapsulation of a group of ball and socket joints, under a common object. It provides common functional 
   shared by all joints in the tree like structure. The rag doll object job is to simplify some of the common task that the programmer encounters 
   when it tries to make a rag doll model by connecting joints.
   It also has some limitations, for example the hierarchy of joints is made of Ball and socket joints, it only support tree like structures of 
   joints, the joints can not by detached from the array once they are added to the rag doll.
   Rag doll joints are good to make articulated creatures, like humans, monsters, horses, etc. 
   They are good to simulate effects like death of a character in a game.
  
<p>   <h4>See also</h4> <a HREF="#NewtonDestroyRagDoll">NewtonDestroyRagDoll</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonDestroyRagDoll"></a>
<a NAME="NewtonDestroyRagDoll"></a>
NewtonDestroyRagDoll
</h3>
<div class=Api>
void <font class=ApiName>NewtonDestroyRagDoll</font>(<br> const NewtonWorld* newtonWorld,<br> const NewtonRagDoll* ragDoll)
</div>
<div class=SectionText>
Destroy a ragdoll containers and all it components.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonRagDoll</b> *ragDoll
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to a rag doll container.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
  
<p>   <h4>See also</h4> <a HREF="#NewtonCreateRagDoll">NewtonCreateRagDoll</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollBegin"></a>
<a NAME="NewtonRagDollBegin"></a>
NewtonRagDollBegin
</h3>
<div class=Api>
void <font class=ApiName>NewtonRagDollBegin</font>(const NewtonRagDoll* ragDoll)
</div>
<div class=SectionText>
Prepare a rag doll object to accept bones and making the skeleton.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDoll</b> *ragDoll
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to a rag doll container.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
  
<p>   <h4>Remarks</h4> This function will clean up the rag doll container of any previously 
   added bone. After the constructions process of the rag doll is completed the application should call  
   <b>NewtonRagDollEnd</b>, not doing so will result in unpredictable results.
  
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollEnd">NewtonRagDollEnd</a>, <a HREF="#NewtonRagDollAddBone">NewtonRagDollAddBone</a>, SetExtForceAndTorqueCallback, SetTransformCallback


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollEnd"></a>
<a NAME="NewtonRagDollEnd"></a>
NewtonRagDollEnd
</h3>
<div class=Api>
void <font class=ApiName>NewtonRagDollEnd</font>(const NewtonRagDoll* ragDoll)
</div>
<div class=SectionText>
Finalized the rag doll construction process.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDoll</b> *ragDoll
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to a rag doll container.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
  
<p>   <h4>Remarks</h4> This function should be called after the constructions process of the rag doll in completed. 
   calling this function without first calling <b>NewtonRagDollBegin</b> will produce unpredictable results.
  
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollBegin">NewtonRagDollBegin</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollAddBone"></a>
<a NAME="NewtonRagDollAddBone"></a>
NewtonRagDollAddBone
</h3>
<div class=Api>
NewtonRagDollBone* <font class=ApiName>NewtonRagDollAddBone</font>(<br> const NewtonRagDoll* ragDoll,<br> const NewtonRagDollBone* parent,<br> void *userData,<br> 
   dFloat mass,<br> const dFloat* matrix,<br> const NewtonCollision* boneCollision,<br> const dFloat* size)
</div>
<div class=SectionText>
Add a bone to a rag doll objects.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDoll</b> *ragDoll
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to a rag doll container.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonRagDollBone</b> *parent
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to the bone parent for this bone. If this is the root bone the <b>parent</b> should be NULL.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userData
</td>
<td class=DefSep>-</td>
<td class=DefText>
user data value. The application can use this parameter to store the pointer on index into the graphical part representing this bone.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> mass
</td>
<td class=DefSep>-</td>
<td class=DefText>
mass of this body part.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *matrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a 4x4 transformation matrix in the local space of the bone. The matrix should be expressed relative to the parent bone.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonCollision</b> *boneCollision
</td>
<td class=DefSep>-</td>
<td class=DefText>
bone collision geometry.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> size
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of three dFloat specifying the size of this body part. The first component of the array is interpreted as the length of the bone.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the handle to a Rag doll bone
  
<p>   <h4>Remarks</h4> The user data value of a rag doll rigid body is set to the <b>NewtonRagDollBone</b>, Unpredictable result will happens if the application set the 
   user data of a rag doll node rigid body.
  
<p>   <h4>Remarks</h4> this function can only be called from inside of a NewtonRagDollBegin/NewtonRagDollEnd pair.
  
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollBegin">NewtonRagDollBegin</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollBoneGetUserData"></a>
<a NAME="NewtonRagDollBoneGetUserData"></a>
NewtonRagDollBoneGetUserData
</h3>
<div class=Api>
void* <font class=ApiName>NewtonRagDollBoneGetUserData</font>(const NewtonRagDollBone* bone)
</div>
<div class=SectionText>
Retrieve a user defined data value stored with the rag doll bone.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDollBone</b> *bone
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the bone.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> The user defined data.
  
<p>   <h4>Remarks</h4> The application can store a user defined value with a rigid body. This value can be the pointer
   to a structure which is the graphical representation of the bone.
   
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollAddBone">NewtonRagDollAddBone</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollSetTransformCallback"></a>
<a NAME="NewtonRagDollSetTransformCallback"></a>
NewtonRagDollSetTransformCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonRagDollSetTransformCallback</font>(<br> const NewtonRagDoll* ragDoll,<br> NewtonSetRagDollTransform callback)
</div>
<div class=SectionText>
Assign a transformation event function to a rag doll object.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDoll</b> *ragDoll
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to a rag doll container.
</td>
</tr>

<p>    
<tr class=Def>
<td class=Def>
NewtonSetRagDollTransform callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a function callback is used to update the transformation matrix of the visual object that represents the rag doll.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> The function <b>NewtonSetRagDollTransform callback</b> is called by the Newton engine every time a visual object that represent a bone of a rag doll has changed.
   The application can obtain the pointer user data value that points to the visual object. 
   The Newton engine does not call the <b>NewtonSetRagDollTransform callback</b> function for bones that are inactive or have reached a state of stable equilibrium.
  
<p>   <h4>Remarks</h4> The user data value of a rag doll rigid body is set to the <b>NewtonRagDollBone</b>, Unpredictable result will happens if the application set the 
   user data of a rag doll node rigid body.
   The application can get the pointer to the application graphical data by retrieving the user data stored with the <b>NewtonRagDollBone</b>. 
  
<p>   <h4>Remarks</h4> The matrix should be organized in row-major order (this is the way directX stores matrices).
   If you are using OpenGL matrices (column-major) you will need to transpose the matrices into a local array, before
   you pass them to Newton.
  
<p>   <h4>Remarks</h4> this function can only be called from inside of a NewtonRagDollBegin/NewtonRagDollEnd pair.
   
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollBegin">NewtonRagDollBegin</a>, <a HREF="#NewtonRagDollAddBone">NewtonRagDollAddBone</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollSetForceAndTorqueCallback"></a>
<a NAME="NewtonRagDollSetForceAndTorqueCallback"></a>
NewtonRagDollSetForceAndTorqueCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonRagDollSetForceAndTorqueCallback</font>(<br> const NewtonRagDoll* ragDoll,<br> NewtonApplyForceAndTorque callback)
</div>
<div class=SectionText>
Assign an event function for applying external force and torque to a Rag doll.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDoll</b> *ragDoll
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to a rag doll container.
</td>
</tr>

<p>    
<tr class=Def>
<td class=Def>
NewtonApplyForceAndTorque callback
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a function callback used to apply force and torque to a rigid body bone.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> this function can be seen as a utility function that will call <b>NewtonBodySetForceAndTorqueCallback</b> for every bone of a rag doll object.
  
<p>   <h4>Remarks</h4> The user data value of a rag doll rigid body is set to the <b>NewtonRagDollBone</b>, unpredictable result will happens if the application set the 
   user data of a rag doll node rigid body. 
   The application can get the pointer to the application graphical data by retrieving the user data stored with the <b>NewtonRagDollBone</b>. 
  
<p>   <h4>Remarks</h4> Before the <b>NewtonApplyForceAndTorque callback</b> is called for a body, Newton first clears the net force and net torque for the body. 
  
<p>   <h4>Remarks</h4> The function <b>NewtonApplyForceAndTorque callback</b> is called by the Newton Engine every time an active body is going to be simulated. 
   The Newton Engine does not call the <b>NewtonApplyForceAndTorque callback</b> function for bodies that are inactive or have reached a state of stable equilibrium.
   
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollBegin">NewtonRagDollBegin</a>, <a HREF="#NewtonRagDollAddBone">NewtonRagDollAddBone</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollBoneSetID"></a>
<a NAME="NewtonRagDollBoneSetID"></a>
NewtonRagDollBoneSetID
</h3>
<div class=SectionText>
Set an id for this particular bone.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDollBone</b> *bone
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to the bone.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id
</td>
<td class=DefSep>-</td>
<td class=DefText>
identifier for this bone.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Nothing.
  
<p>   <h4>Remarks</h4> during the construction, the application has the option to set an identifier for each bone. It is good idea to make this identifier unique for the rag doll.
   
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollAddBone">NewtonRagDollAddBone</a>, <a HREF="#NewtonRagDollFindBone">NewtonRagDollFindBone</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollFindBone"></a>
<a NAME="NewtonRagDollFindBone"></a>
NewtonRagDollFindBone
</h3>
<div class=Api>
NewtonRagDollBone* <font class=ApiName>NewtonRagDollFindBone</font>(<br> const NewtonRagDoll* ragDoll,<br> int id)
</div>
<div class=SectionText>
Find the first bone with this id in this rag doll.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDoll</b> *ragDoll
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to a rag doll container.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> id
</td>
<td class=DefSep>-</td>
<td class=DefText>
identifier for this bone.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the handle to the bone with this identifier. NULL if no bone in the rag doll has this id
  
<p>   <h4>Remarks</h4> during the construction, the application has the option to set an identifier for each bone. It is good idea to make this identifier unique for the rag doll.
   the application can use this id to find particular bones in the rag doll body. This is useful for authoring tolls.
   
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollBoneSetID">NewtonRagDollBoneSetID</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollBoneGetBody"></a>
<a NAME="NewtonRagDollBoneGetBody"></a>
NewtonRagDollBoneGetBody
</h3>
<div class=Api>
NewtonBody* <font class=ApiName>NewtonRagDollBoneGetBody</font>(const NewtonRagDollBone* bone)
</div>
<div class=SectionText>
Retrieve the rigid body assigned to this bone.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDollBone</b> *bone
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to the bone.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> The rigid body assigned to this bone
  
<p>   <h4>Remarks</h4> this function can be used to customized some of the properties of the rigid body assigned to the bone.
   the application should not override the pointer to <b>TransformCallback</b> or <b>ApplyForceAndTorque</b> of a rigid body assigned 
   to a Rag doll bone. It should call the functions <b>NewtonRagDollSetTransformCallback</b> and <b>NewtonRagDollSetForceAndTorqueCallback</b> instead.
   
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollAddBone">NewtonRagDollAddBone</a>, <a HREF="#NewtonRagDollSetTransformCallback">NewtonRagDollSetTransformCallback</a>, <a HREF="#NewtonRagDollSetForceAndTorqueCallback">NewtonRagDollSetForceAndTorqueCallback</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollBoneSetLimits"></a>
<a NAME="NewtonRagDollBoneSetLimits"></a>
NewtonRagDollBoneSetLimits
</h3>
<div class=Api>
void <font class=ApiName>NewtonRagDollBoneSetLimits</font>(<br> const NewtonRagDollBone* bone,<br> const dFloat* coneDir,<br> dFloat minConeAngle,<br> dFloat maxConeAngle,<br> dFloat maxTwistAngle,<br> const dFloat* lateralConeDir,<br> dFloat negativeBilateralConeAngle,<br> dFloat positiveBilateralConeAngle)
</div>
<div class=SectionText>
Set the stop limits for this bone.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDollBone</b> *bone
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to this particular bone. If this parameter is the root bone, then the limits do not have any effect.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *coneDir
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of tree dFloat specifying the direction in global space of the cone limits for this bone.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> minConeAngle
</td>
<td class=DefSep>-</td>
<td class=DefText>
minimum value of the cone of the cone limit.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> maxConeAngle
</td>
<td class=DefSep>-</td>
<td class=DefText>
maximum value of the cone of the cone limit.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> maxTwistAngle
</td>
<td class=DefSep>-</td>
<td class=DefText>
maximum and minimum that this bone is allow to spin around the coneDir.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *lateralConeDir
</td>
<td class=DefSep>-</td>
<td class=DefText>
this parameter is ignored in this release.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> negativeBilateralConeAngle
</td>
<td class=DefSep>-</td>
<td class=DefText>
this parameter is ignored in this release.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> negativeBilateralConeAngle
</td>
<td class=DefSep>-</td>
<td class=DefText>
this parameter is ignored in this release.
</td>
</tr>
</table>

<p>  
  
<p>   <h4>Remarks</h4> This function set a cone fixed on the frame of the parent of this bone and defining the work space of the bone.
  
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollBegin">NewtonRagDollBegin</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollBoneGetLocalMatrix"></a>
<a NAME="NewtonRagDollBoneGetLocalMatrix"></a>
NewtonRagDollBoneGetLocalMatrix
</h3>
<div class=Api>
void <font class=ApiName>NewtonRagDollBoneGetLocalMatrix</font>(<br> const NewtonRagDollBone* bone,<br> dFloat* matrixPtr)
</div>
<div class=SectionText>
Get the transformation matrix for this bone in the local space of the bone.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDollBone</b> *bone
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to this particular bone. If this parameter is the root bone, then the limits do not have any effect.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *matrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a 4x4 transformation matrix to receive the transformation matrix for this bone.
</td>
</tr>
</table>

<p>  
   <h4>Remarks</h4> the application can call this function from a NewtonSetRagDollTransform to get the transformation matrix for the graphical representation of the bone in local space.
  
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollSetTransformCallback">NewtonRagDollSetTransformCallback</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonRagDollBoneGetGlobalMatrix"></a>
<a NAME="NewtonRagDollBoneGetGlobalMatrix"></a>
NewtonRagDollBoneGetGlobalMatrix
</h3>
<div class=Api>
void <font class=ApiName>NewtonRagDollBoneGetGlobalMatrix</font>(<br> const NewtonRagDollBone* bone,<br> dFloat* matrixPtr)
</div>
<div class=SectionText>
Get the transformation matrix for this bone in the global space of the bone.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonRagDollBone</b> *bone
</td>
<td class=DefSep>-</td>
<td class=DefText>
handle to this particular bone. If this parameter is the root bone, then the limits do not have any effect.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> *matrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a 4x4 transformation matrix to receive the transformation matrix for this bone.
</td>
</tr>
</table>

<p>  
   <h4>Remarks</h4> the application can call this function from a NewtonSetRagDollTransform to get the transformation matrix for the graphical representation of the bone in global space.
  
<p>   <h4>See also</h4> <a HREF="#NewtonRagDollSetTransformCallback">NewtonRagDollSetTransformCallback</a> 


</div>
</div>
<div class=Section>
<h3>
<a NAME="Vehicle^constraint^interface"></a>
<a NAME="Vehicle constraint interface"></a>
Vehicle constraint interface
</h3>
<div class=SectionText>

                                                                                                                  
<p>

</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonConstraintCreateVehicle"></a>
<a NAME="NewtonConstraintCreateVehicle"></a>
NewtonConstraintCreateVehicle
</h3>
<div class=Api>
NewtonJoint* <font class=ApiName>NewtonConstraintCreateVehicle</font>(<br> const NewtonWorld* newtonWorld,<br> const dFloat* upDir,<br> const NewtonBody* body)
</div>
<div class=SectionText>
Create and empty vehicle joint.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonWorld</b> *newtonWorld
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the Newton world.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *upDir
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the unit vector defined by the tires pivot points, usually the opposite direction to the gravity vector.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const NewtonBody</b> *body
</td>
<td class=DefSep>-</td>
<td class=DefText>
is the pointer to the attached rigid body, this body can not be NULL or it can not have an infinity (zero) mass.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Pointer to the vehicle joint.
  
<p>   <h4>Remarks</h4> This joint provides basics functionality for simulating real-time simplistic vehicle dynamics. The joint is not meant to be and 
   accurate and realistic representation of a real vehicle, that is out of the scope of a real-time physics engine. The vehicle is made out 
   of a main rigid body visible to the application and attached to it a set of tires not visible to the application directly as rigid bodies.
   The tires are connected to the body via rigid wheel joints providing the ability for the tire to spin, have suspension, and turn. The 
   internal vehicle mechanics like transmission, power transfer shaft, suspension mechanism, doors etc. It only models the vehicle body 
   mounted on a set of wheels, with suspension and the ability to roll. 


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleSetTireCallback"></a>
<a NAME="NewtonVehicleSetTireCallback"></a>
NewtonVehicleSetTireCallback
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleSetTireCallback</font>(<br> const NewtonJoint* vehicle,<br> NewtonVehicleTireUpdate update)
</div>
<div class=SectionText>
Store a function callback pointer for vehicle update.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>NewtonVehicleTireUpdate</b> update
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the callback function.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
  
<p>   <h4>Remarks</h4> The only way to control a vehicle is by implementing the vehicle update callback. 
   The application should iterate through each tire applying tire dynamics to each one. 
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleGetFirstTireID">NewtonVehicleGetFirstTireID</a>, <a HREF="#NewtonVehicleGetNextTireID">NewtonVehicleGetNextTireID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleAddTire"></a>
<a NAME="NewtonVehicleAddTire"></a>
NewtonVehicleAddTire
</h3>
<div class=Api>
void* <font class=ApiName>NewtonVehicleAddTire</font>(<br> const NewtonJoint* vehicle,<br> const dFloat* localMatrix,<br> const dFloat* pin,<br> dFloat mass,<br> dFloat width,<br> dFloat radius,<br> 
	dFloat suspesionShock,<br> dFloat suspesionSpring,<br> dFloat suspesionLength,<br> void* userData,<br> int collisionID)
</div>
<div class=SectionText>
Add a new tire to the vehicle container.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> *localMatrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the offset of the tire relative to the vehicle body.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>const dFloat</b> pin
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 3 floats containing the rotation axis of the tire, in the space of the tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> mass
</td>
<td class=DefSep>-</td>
<td class=DefText>
tire mass, must be much smaller than the vehicle body. ratio of 50:1 to 100:1 are the recommended values.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> width
</td>
<td class=DefSep>-</td>
<td class=DefText>
width of the tire, must be smaller than the tire radius.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> radius
</td>
<td class=DefSep>-</td>
<td class=DefText>
tire radius.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> suspesionShock
</td>
<td class=DefSep>-</td>
<td class=DefText>
parametrized damping constant for a spring, mass, damper system. A value of one corresponds to a critically damped system.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> suspesionSpring
</td>
<td class=DefSep>-</td>
<td class=DefText>
parametrized spring constant for a spring, mass, damper system. A value of one corresponds to a critically damped system.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> suspesionLength
</td>
<td class=DefSep>-</td>
<td class=DefText>
distance from the tire set position to the upper stop on the vehicle body frame. The total suspension length is twice that.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *userData
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to a user define data value. Usually used to store the pointer to the graphical representation of the tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>int</b> collisionID
</td>
<td class=DefSep>-</td>
<td class=DefText>
the collision ID use by the application to identify the tire contacts in a contact callback function.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> the tire ID.
  
<p>   <h4>Remarks</h4> After the application creates the vehicle joint, it must add the tires. 
   Tires are added one at a time at the graphics set position and with the appropriate.
   the application should calculate the correct tire parameters, like tire mass, position, width height,
   spring and damper constants.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleRemoveTire">NewtonVehicleRemoveTire</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleReset"></a>
<a NAME="NewtonVehicleReset"></a>
NewtonVehicleReset
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleReset</font>(const NewtonJoint* vehicle)
</div>
<div class=SectionText>
Reset all tires velocities to zero. 
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   This function is useful for reposition the vehicle.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleRemoveTire"></a>
<a NAME="NewtonVehicleRemoveTire"></a>
NewtonVehicleRemoveTire
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleRemoveTire</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Detach and destroy a tire from the vehicle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
tire index to be destroyed.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetFirstTireID"></a>
<a NAME="NewtonVehicleGetFirstTireID"></a>
NewtonVehicleGetFirstTireID
</h3>
<div class=Api>
void* <font class=ApiName>NewtonVehicleGetFirstTireID</font>(const NewtonJoint* vehicle)
</div>
<div class=SectionText>
Get the index of the first tire of the vehicle tire set.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> tire index.
  
<p>   <h4>Remarks</h4> This function is usually used from inside the vehicle update callback. It is used to iterate through the tire set applying the tire dynamics.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleGetNextTireID">NewtonVehicleGetNextTireID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetNextTireID"></a>
<a NAME="NewtonVehicleGetNextTireID"></a>
NewtonVehicleGetNextTireID
</h3>
<div class=Api>
void* <font class=ApiName>NewtonVehicleGetNextTireID</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Get the index of the next tire on the tire set.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Next tire index, or zero if index <b>tireId</b> was pointing to the last tire in the set.
  
<p>   <h4>Remarks</h4> This function is usually used from inside a tire update callback. It is used to iterate through the tire set applying the tire dynamics.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleGetFirstTireID">NewtonVehicleGetFirstTireID</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetTireUserData"></a>
<a NAME="NewtonVehicleGetTireUserData"></a>
NewtonVehicleGetTireUserData
</h3>
<div class=SectionText>
Retrieve the pointer to the tire user data.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> tire user data.
  
<p>   <h4>Remarks</h4> This function is usually used from the vehicle update callback or from transformation callback of the vehicle body, 
   It can used do set the transformation matrix of the tire graphical representation.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetTireMatrix"></a>
<a NAME="NewtonVehicleGetTireMatrix"></a>
NewtonVehicleGetTireMatrix
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleGetTireMatrix</font>(<br> const NewtonJoint* vehicle,<br> void* tireId,<br> dFloat* matrix)
</div>
<div class=SectionText>
Retrieve the transformation matrix of the tire in global space.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> matrix
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to an array of 16 floats containing the global matrix of the tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing
  
<p>   <h4>Remarks</h4> This function is usually used from the tire update callback or from transformation callback of the vehicle body, 
   It can be used to set the transformation of the tire graphical representation.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetTireSteerAngle"></a>
<a NAME="NewtonVehicleGetTireSteerAngle"></a>
NewtonVehicleGetTireSteerAngle
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonVehicleGetTireSteerAngle</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Get the tire steering angle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> steering angle.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application wants to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleSetTireSteerAngle"></a>
<a NAME="NewtonVehicleSetTireSteerAngle"></a>
NewtonVehicleSetTireSteerAngle
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleSetTireSteerAngle</font>(<br> const NewtonJoint* vehicle,<br> void* tireId,<br> dFloat angle)
</div>
<div class=SectionText>
Set the tire steering angle.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> angle
</td>
<td class=DefSep>-</td>
<td class=DefText>
new steering angle.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application wants to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleSetTireTorque"></a>
<a NAME="NewtonVehicleSetTireTorque"></a>
NewtonVehicleSetTireTorque
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleSetTireTorque</font>(<br> const NewtonJoint* vehicle,<br> void* tireId,<br> dFloat torque)
</div>
<div class=SectionText>
Set the tire torque.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> torque
</td>
<td class=DefSep>-</td>
<td class=DefText>
new torque value.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> This function is useful to simulate normal vehicles with wheels that propel by applying torque to a the tire axis
   in order to move.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application wants to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetTireOmega"></a>
<a NAME="NewtonVehicleGetTireOmega"></a>
NewtonVehicleGetTireOmega
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonVehicleGetTireOmega</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Retrieve the tire angular velocity.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> angular velocity.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application wants to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetTireNormalLoad"></a>
<a NAME="NewtonVehicleGetTireNormalLoad"></a>
NewtonVehicleGetTireNormalLoad
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonVehicleGetTireNormalLoad</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Return the part of the vehicle weight supported by this tire.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> magnitude of the vehicle weight supported by this tire.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application wants to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleTireSetBrakeAcceleration"></a>
<a NAME="NewtonVehicleTireSetBrakeAcceleration"></a>
NewtonVehicleTireSetBrakeAcceleration
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleTireSetBrakeAcceleration</font>(<br> const NewtonJoint* vehicle,<br> void* tireId,<br> dFloat acceleration,<br> dFloat maxFrictionTorque)
</div>
<div class=SectionText>
Apply the acceleration and max friction torque to a tire axis.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> acceleration
</td>
<td class=DefSep>-</td>
<td class=DefText>
desire tire acceleration.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> maxFrictionTorque
</td>
<td class=DefSep>-</td>
<td class=DefText>
maximum friction torque the tire brake, or tire motor can withstand.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> noting.
  
<p>   <h4>Remarks</h4> This is a multipurpose function. The more common use is to apply hand or soft brakes to a vehicle. 
   To apply brakes the application may use the function <b>NewtonVehicleTireSetBrakeAcceleration</b> to determine the exact acceleration
   needed to stop the tire from continue to spin in one frame. To simulated the variable brakes strength the application can use 
   a nominal maximum friction torque (just like in real life any device will withstand a max value) and modulate this value with an analog 
   control. For hand brakes the application set the control to the maximum and for soft brakes it can just modulate the variable friction.
   Another use for this function is to simulate rolling friction, For this effect the application apply the acceleration to stop
   but with a friction value set to a minimum non zero fixed value. Note that brakes and tire torque are not mutually exclusive, 
   the application can apply then simultaneously. As a matter of fact doing so is quite a satisfying test showing how the vehicles rocks 
   forth and back due to the engine torque, while the tire prevent it from moving. Another use for this function is the simulation of 
   track based vehicles. For this the application apply an arbitrary fix acceleration to 
   the tires on each side of the vehicle. A function as simple as <b>A = Ad minus Ks x Omega</b> can do the trick, where Ad is the desire acceleration 
   controlled by the application joystick, Ks is some viscous velocity damping, and omega is the current tire angular velocity reported by the 
   function <b>NewtonVehicleGetTireOmega</b>. 
   To make the vehicle take turns the application can elaborate the equation like <b>A = Ad + At minus Ks x Omega</b> where At is the differential 
   acceleration supplied by the steering control, for the tires on the right side At is positive while for tires of the left side At is negative.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application wants to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleTireCalculateMaxBrakeAcceleration">NewtonVehicleTireCalculateMaxBrakeAcceleration</a>, <a HREF="#NewtonVehicleGetTireOmega">NewtonVehicleGetTireOmega</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleTireCalculateMaxBrakeAcceleration"></a>
<a NAME="NewtonVehicleTireCalculateMaxBrakeAcceleration"></a>
NewtonVehicleTireCalculateMaxBrakeAcceleration
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonVehicleTireCalculateMaxBrakeAcceleration</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Calculate the exact acceleration needed to be applied to a tire axis in order to bring it to full stop in one time step.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> exact acceleration for full stop of the tire.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleTireSetBrakeAcceleration">NewtonVehicleTireSetBrakeAcceleration</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetTireLateralSpeed"></a>
<a NAME="NewtonVehicleGetTireLateralSpeed"></a>
NewtonVehicleGetTireLateralSpeed
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonVehicleGetTireLateralSpeed</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Return the tire speed along the tire pin axis.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> tire lateral speed.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleGetTireLongitudinalSpeed"></a>
<a NAME="NewtonVehicleGetTireLongitudinalSpeed"></a>
NewtonVehicleGetTireLongitudinalSpeed
</h3>
<div class=Api>
dFloat <font class=ApiName>NewtonVehicleGetTireLongitudinalSpeed</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Return the tire speed along the axis perpendicular to the tire pin axis and the vehicle upvector.
  
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> tire longitudinal speed.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleSetTireMaxSideSleepSpeed"></a>
<a NAME="NewtonVehicleSetTireMaxSideSleepSpeed"></a>
NewtonVehicleSetTireMaxSideSleepSpeed
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleSetTireMaxSideSleepSpeed</font>(<br> const NewtonJoint* vehicle,<br> void* tireId,<br> dFloat speed)
</div>
<div class=SectionText>
Set the maximum side slip velocity for the tire to be considered to lose grip.
   
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> speed
</td>
<td class=DefSep>-</td>
<td class=DefText>
maximum side speed before the vehicle is considered to loose side grip.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> Tire operation involve a mix of elastic distortion and sliding friction. To have and idea how to code a convincing 
   approximation of a real tire we must run some experiment and make some reflection upon the result. First we will run a static 
   test: keeping a tire at equilibrium applying a constant load and without rolling, we will apply a lateral force perpendicular 
   to the tire plane and applied at the tire center. If we run this experiment we will find that the tire will deflect in response 
   to the lateral force. If we increase the magnitude of the lateral force, the magnitude of the deflection is proportional to the 
   magnitude of the lateral force, until the tire begins to slide. This show that when a tire is not moving it behaves like a spring 
   (elastic distortion). If we repeat this experiment but this time increasing the tire load, but still not moving the tire, we will 
   see that the max deflection is proportional to the magnitude of the tire load. This indicates the tire behavior is proportional 
   to two variables, the lateral force and the tire load. (Fortunately the side force in practice is a linear function of the tire 
   load so this keeps the model simple) Now we will run the first experiment but this time we will rotate the tire with a constant 
   angular velocity (think of those tune up machines at check up stations.) With the tire rolling at constant angular velocity if we 
   apply a lateral force we will see that as the tire deflect, the part of the tire in contact with the floor keeps rolling and another
   part take its place, but this part also start to deflect, allowing the tire to move sideways with a velocity proportional to the 
   tire rolling angular velocity. Notice that the tire does this without sliding as the part of it in contact with the floor never 
   loses grip. Now if we increase the lateral force we will find that the lateral speed of the tire will also increase. This suggests 
   that the side speed of the tire is proportional to the lateral force and also proportional to the rolling angular velocity. This 
   is the tire elastic properties give then some kind of damping property when they are rolling. There is not known macroscopic 
   mathematical model that can explain this behavior. The best we can do is to write the values of the experiment and use then to 
   interpolate and extrapolate intermediate values. One thing we know is that the tires operates within some limits, and we can use 
   those parameters to treat then as a constraint optimization problem, which is the Newton approach. When the tire is rolling and 
   side slipping is not that the tire lost grip, nor that the tire is generating some force. It is rather that the tire have the 
   capacity to absorb some of the lateral force by sliding and convert it to side velocity, this means that for the tire to 
   loose grip a stronger force is necessary. In another word at rest a tire will lose grip under a much lower lateral force than 
   if the tire was rolling. In Newton this behavior is treaded as a constrain optimization problem by asking the application how 
   much side slip velocity is the tire allow to have before it is considered to lose grip, and how much of the lateral forces 
   generated by the rigid body dynamics will be adsorbed by the tire at a given speed. It is the application responsibility to 
   set these parameters as close to the real tire as it chooses. This approach allows for a very wide range of behaviors form arcade, 
   to toy cars to very realistic.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleSetTireSideSleepCoeficient">NewtonVehicleSetTireSideSleepCoeficient</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleSetTireSideSleepCoeficient"></a>
<a NAME="NewtonVehicleSetTireSideSleepCoeficient"></a>
NewtonVehicleSetTireSideSleepCoeficient
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleSetTireSideSleepCoeficient</font>(<br> const NewtonJoint* vehicle,<br> void* tireId,<br> dFloat coeficient)
</div>
<div class=SectionText>
Set the coefficient that tell the engine how much of the lateral force can be absorbed by the tire.
   
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> coeficient
</td>
<td class=DefSep>-</td>
<td class=DefText>
side slip coeficient.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> See description of side slip on function <b>NewtonVehicleSetTireMaxSideSleepSpeed</b>
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleSetTireMaxSideSleepSpeed">NewtonVehicleSetTireMaxSideSleepSpeed</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleSetTireMaxLongitudinalSlideSpeed"></a>
<a NAME="NewtonVehicleSetTireMaxLongitudinalSlideSpeed"></a>
NewtonVehicleSetTireMaxLongitudinalSlideSpeed
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleSetTireMaxLongitudinalSlideSpeed</font>(<br> const NewtonJoint* vehicle,<br> void* tireId,<br> dFloat speed)
</div>
<div class=SectionText>
Set the maximum side slide velocity for the tire to be considered to lose traction.
   
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> speed
</td>
<td class=DefSep>-</td>
<td class=DefText>
maximum side speed before the vehicle is considered to loose side traction.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> The explanation of longitudinal slide is similar to the side slip, however it is not so critical to achieve realistic behavior.
   See description of side slip on function <b>NewtonVehicleSetTireMaxSideSleepSpeed</b>
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleSetTireLongitudinalSlideCoeficient">NewtonVehicleSetTireLongitudinalSlideCoeficient</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleSetTireLongitudinalSlideCoeficient"></a>
<a NAME="NewtonVehicleSetTireLongitudinalSlideCoeficient"></a>
NewtonVehicleSetTireLongitudinalSlideCoeficient
</h3>
<div class=Api>
void <font class=ApiName>NewtonVehicleSetTireLongitudinalSlideCoeficient</font>(<br> const NewtonJoint* vehicle,<br> void* tireId,<br> dFloat coeficient)
</div>
<div class=SectionText>
Set the coefficient that tell the engine how much of the longitudinal force can be absorbed by the tire.
   
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>dFloat</b> coefficient
</td>
<td class=DefSep>-</td>
<td class=DefText>
longitudinal slide coefficient.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> nothing.
  
<p>   <h4>Remarks</h4> The explanation of longitudinal slide is similar to the side slip, however it is not so critical to achieve realistic behavior.
   See description of side slip on function <b>NewtonVehicleSetTireMaxSideSleepSpeed</b>
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.
  
<p>   <h4>See also</h4> <a HREF="#NewtonVehicleSetTireMaxLongitudinalSlideSpeed">NewtonVehicleSetTireMaxLongitudinalSlideSpeed</a>


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleTireIsAirBorne"></a>
<a NAME="NewtonVehicleTireIsAirBorne"></a>
NewtonVehicleTireIsAirBorne
</h3>
<div class=Api>
int <font class=ApiName>NewtonVehicleTireIsAirBorne</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Return a boolean value that tells the application if this tire is touching the ground.
   
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> airborne state 1 on the air, 0 on the ground.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleTireLostSideGrip"></a>
<a NAME="NewtonVehicleTireLostSideGrip"></a>
NewtonVehicleTireLostSideGrip
</h3>
<div class=Api>
int <font class=ApiName>NewtonVehicleTireLostSideGrip</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Return a boolean value that tell the application if this tire lost side grip..
   
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> Grip state.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
<div class=Section>
<h3>
<a NAME="NewtonVehicleTireLostTraction"></a>
<a NAME="NewtonVehicleTireLostTraction"></a>
NewtonVehicleTireLostTraction
</h3>
<div class=Api>
int <font class=ApiName>NewtonVehicleTireLostTraction</font>(<br> const NewtonJoint* vehicle,<br> void* tireId)
</div>
<div class=SectionText>
Return a boolean value that tell the application if this tire lost longitudinal traction.
   
<p>   <h4>Parameters</h4>
   
<p><table class=DefTable>
<tr class=Def>
<td class=Def>
<b>const NewtonJoint</b> *vehicle
</td>
<td class=DefSep>-</td>
<td class=DefText>
pointer to the vehicle joint.
</td>
</tr>

<p>   
<tr class=Def>
<td class=Def>
<b>void</b> *tireId
</td>
<td class=DefSep>-</td>
<td class=DefText>
index to current tire.
</td>
</tr>
</table>

<p>  
   <h4>Return</h4> traction state.
  
<p>   <h4>Remarks</h4> The vehicle joint provides a rich set of interface functions to the application. Which function to use 
   is only determined by the level of fidelity the application want to achieve. In not case the use of one method is better than 
   other, and it may be that some tweaking and trial is necessary before the desired vehicle behavior is achieved.
  
<p>   <h4>Remarks</h4> The parameters applied to a tire are reset to default values each time the update function is called.
   So the application should set the desired value in each simulation frame.
  
<p>   <h4>Remarks</h4> This function can only be called from the vehicle update call back. It can be used by the application to generate the custom vehicle dynamics.


</div>
</div>
</div>
</body>
</html>

